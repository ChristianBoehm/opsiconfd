# -*- coding: utf-8 -*-

# opsiconfd is part of the desktop management solution opsi http://www.opsi.org
# Copyright (c) 2020-2021 uib GmbH <info@uib.de>
# All rights reserved.
# License: AGPL-3.0
"""
session handling
"""
# pylint: disable=too-many-lines

from __future__ import annotations

import asyncio
import base64
import random
import re
import time
import uuid
from collections import namedtuple
from time import sleep as time_sleep
from typing import Any, Optional

import msgspec
import pyotp
from fastapi import FastAPI, HTTPException, status
from fastapi.exceptions import ValidationException
from fastapi.requests import HTTPConnection
from fastapi.responses import (
	JSONResponse,
	PlainTextResponse,
	RedirectResponse,
	Response,
)
from opsicommon.exceptions import (  # type: ignore[import]
	BackendAuthenticationError,
	BackendPermissionDeniedError,
)
from opsicommon.logging import secret_filter, set_context  # type: ignore[import]
from opsicommon.objects import Host, OpsiClient, User  # type: ignore[import]
from opsicommon.utils import ip_address_in_network, timestamp
from packaging.version import Version
from redis import ResponseError as RedisResponseError
from starlette.concurrency import run_in_threadpool
from starlette.datastructures import Headers, MutableHeaders
from starlette.types import Message, Receive, Scope, Send
from websockets import ConnectionClosedError

from opsiconfd import contextvar_client_session, server_timing
from opsiconfd.addon import AddonManager
from opsiconfd.application import MaintenanceState
from opsiconfd.application import app as opsiconfd_app
from opsiconfd.auth import AuthenticationModule
from opsiconfd.auth.ldap import LDAPAuthentication
from opsiconfd.auth.pam import PAMAuthentication
from opsiconfd.auth.user import create_user
from opsiconfd.backend import (
	get_unprotected_backend,  # pylint: disable=import-outside-toplevel
)
from opsiconfd.config import config, opsi_config
from opsiconfd.logging import logger
from opsiconfd.redis import async_redis_client, ip_address_to_redis_key, redis_client
from opsiconfd.utils import asyncio_create_task, utc_time_timestamp

# https://github.com/tiangolo/fastapi/blob/master/docs/tutorial/middleware.md
#
# You can add middleware to FastAPI applications.
#
# A "middleware" is a function that works with every request before it is processed by any specific path operation.
# And also with every response before returning it.
#
# 	It takes each request that comes to your application.
# 	It can then do something to that request or run any needed code.
# 	Then it passes the request to be processed by the rest of the application (by some path operation).
# 	It then takes the response generated by the application (by some path operation).
# 	It can do something to that response or run any needed code.
# 	Then it returns the response.

ACCESS_ROLE_PUBLIC = "public"
ACCESS_ROLE_AUTHENTICATED = "authenticated"
ACCESS_ROLE_ADMIN = "admin"
SESSION_COOKIE_NAME = "opsiconfd-session"
SESSION_COOKIE_ATTRIBUTES = ("SameSite=Strict", "Secure")
MESSAGEBUS_IN_USE_TIMEOUT = 40
# Zsync2 will send "curl/<curl-version>" as User-Agent.
# RedHat / Alma / Rocky package manager will send "libdnf (<os-version>)".
# Do not keep sessions because they will never send a cookie (session id).
# If we keep the session, we may reach the maximum number of sessions per ip.
SESSION_UNAWARE_USER_AGENTS = ("libdnf", "curl")
# Store ip addresses of depots with last access time
depot_addresses: dict[str, float] = {}

session_data_msgpack_encoder = msgspec.msgpack.Encoder()
session_data_msgpack_decoder = msgspec.msgpack.Decoder()

BasicAuth = namedtuple("BasicAuth", ["username", "password"])


def get_basic_auth(headers: Headers) -> BasicAuth:
	auth_header = headers.get("authorization")

	headers_401 = {}
	if headers.get("X-Requested-With", "").lower() != "xmlhttprequest":
		headers_401 = {"WWW-Authenticate": 'Basic realm="opsi", charset="UTF-8"'}

	if not auth_header:
		raise HTTPException(
			status_code=status.HTTP_401_UNAUTHORIZED,
			detail="Authorization header missing",
			headers=headers_401,
		)

	if not auth_header.startswith("Basic "):
		raise HTTPException(
			status_code=status.HTTP_401_UNAUTHORIZED,
			detail="Authorization method unsupported",
			headers=headers_401,
		)

	encoded_auth = auth_header[6:]  # Stripping "Basic "
	secret_filter.add_secrets(encoded_auth)
	auth = base64.decodebytes(encoded_auth.encode("ascii")).decode("utf-8")

	if auth.count(":") == 6:
		# Seems to be a mac address as username
		username, password = auth.rsplit(":", 1)
	else:
		username, password = auth.split(":", 1)
	secret_filter.add_secrets(password)

	return BasicAuth(username, password)


class SessionMiddleware:
	def __init__(self, app: FastAPI, public_path: list[str] | None = None) -> None:
		self.app = app
		self._public_path = public_path or []
		self._overload_until = 0.0

	def set_overload(self, duration: float = 30.0) -> None:
		self._overload_until = time.time() + duration
		logger.warning("Server overload set until %r", self._overload_until)

	def check_overload(self) -> float:
		if self._overload_until <= 0:
			return 0.0
		time_left = self._overload_until - time.time()
		if time_left <= 0:
			self._overload_until = 0.0
			logger.notice("Server overload reset")
			return 0.0
		return time_left

	@staticmethod
	def get_session_id_from_headers(headers: Headers) -> Optional[str]:
		# connection.cookies.get(SESSION_COOKIE_NAME, None)
		# Not working for opsi-script, which sometimes sends:
		# 'NULL; opsiconfd-session=7b9efe97a143438684267dfb71cbace2'
		# Workaround:
		session_cookie_name = SESSION_COOKIE_NAME
		cookies = headers.get("cookie")
		if cookies:
			for cookie in cookies.split(";"):
				cookie_l = cookie.strip().split("=", 1)
				if len(cookie_l) == 2:
					if cookie_l[0].strip().lower() == session_cookie_name:
						return cookie_l[1].strip().lower()
		return None

	async def handle_request(  # pylint: disable=too-many-locals,too-many-branches,too-many-statements
		self, connection: HTTPConnection, receive: Receive, send: Send
	) -> None:
		overload_time_left = self.check_overload()
		if overload_time_left and connection.scope["client"][0] not in ("127.0.0.1", "::1"):
			retry_after = int(overload_time_left + random.randint(10, 300))
			raise HTTPException(
				status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
				detail="Server overload",
				headers={"Retry-After": str(retry_after)},
			)
		if isinstance(opsiconfd_app.app_state, MaintenanceState):
			client_in_exceptions = False
			for network in opsiconfd_app.app_state.address_exceptions or []:
				if ip_address_in_network(connection.scope["client"][0], network):
					client_in_exceptions = True
					break
			if not client_in_exceptions:
				raise HTTPException(
					status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
					detail=opsiconfd_app.app_state.message,
					headers={"Retry-After": str(opsiconfd_app.app_state.retry_after)},
				)

		with server_timing("session_handling") as timing:
			scope = connection.scope
			scope["session"] = None
			logger.trace("SessionMiddleware %s", scope)

			await check_network(scope["client"][0])

			if scope["type"] not in ("http", "websocket"):
				await self.app(scope, receive, send)
				return

			# Set default access role
			required_access_role = ACCESS_ROLE_ADMIN
			access_role_public = ACCESS_ROLE_PUBLIC
			if scope["full_path"]:
				if scope["full_path"] == "/":
					required_access_role = access_role_public
				for pub_path in self._public_path:
					if scope["full_path"].startswith(pub_path):
						required_access_role = access_role_public
						break
			scope["required_access_role"] = required_access_role

			if scope["full_path"].startswith(("/rpc", "/monitoring", "/messagebus", "/file-transfer")) or (
				scope["full_path"].startswith(("/depot", "/boot")) and scope.get("method") in ("GET", "HEAD", "OPTIONS", "PROPFIND")
			):
				scope["required_access_role"] = ACCESS_ROLE_AUTHENTICATED

			# Get session
			session_id = self.get_session_id_from_headers(connection.headers)
			if scope["required_access_role"] != ACCESS_ROLE_PUBLIC or session_id:
				addr = scope["client"]
				scope["session"] = await session_manager.get_session(client_addr=addr[0], headers=connection.headers, session_id=session_id)

			started_authenticated = scope["session"] and scope["session"].authenticated

			# Addon request processing
			if scope["full_path"].startswith("/addons"):
				addon = AddonManager().get_addon_by_path("/".join(scope["full_path"].split("/", 3)[:3]))
				if addon:
					logger.debug("Calling %s.handle_request for path '%s'", addon, scope["full_path"])
					if await addon.handle_request(connection, receive, send):
						return

			await check_access(connection)
			if (
				scope["session"]
				and required_access_role == ACCESS_ROLE_ADMIN
				and not scope["session"].host
				and scope["full_path"].startswith("/depot")
				and opsi_config.get("groups", "fileadmingroup") not in scope["session"].user_groups
			):
				raise BackendPermissionDeniedError(f"Not a file admin user '{scope['session'].username}'")

		if started_authenticated and timing["session_handling"] > 1000:
			logger.warning("Session handling took %0.2fms", timing["session_handling"])

		async def send_wrapper(message: Message) -> None:
			if message["type"] == "http.response.start":
				headers = MutableHeaders(scope=message)
				if scope["session"]:
					scope["session"].add_cookie_to_headers(headers)
				if scope.get("response-headers"):
					for key, value in scope["response-headers"].items():
						headers.append(key, value)
			await send(message)

		await self.app(scope, receive, send_wrapper)

	async def handle_request_exception(  # pylint: disable=too-many-locals,too-many-branches,too-many-statements
		self, err: Exception, connection: HTTPConnection, receive: Receive, send: Send
	) -> None:
		logger.debug("Handle request exception %s: %s", err.__class__.__name__, err, exc_info=True)
		scope = connection.scope
		if scope["full_path"].startswith("/addons"):
			addon = AddonManager().get_addon_by_path(scope["full_path"])
			if addon:
				logger.debug("Calling %s.handle_request_exception for path '%s'", addon, scope["full_path"])
				if await addon.handle_request_exception(err, connection, receive, send):
					return

		status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
		headers = None
		error = None

		if isinstance(err, (BackendAuthenticationError, BackendPermissionDeniedError)):
			log = logger.warning

			if scope["path"]:
				if scope.get("method") == "MKCOL" and scope["path"].lower().endswith("/system volume information"):
					# Windows WebDAV client is trying to create "System Volume Information"
					log = logger.debug
				elif scope.get("method") == "PROPFIND" and scope["path"] == "/":
					# Windows WebDAV client PROPFIND /
					log = logger.debug
			log(err)

			status_code = status.HTTP_401_UNAUTHORIZED
			if connection.headers.get("X-Requested-With", "").lower() != "xmlhttprequest":
				headers = {"WWW-Authenticate": 'Basic realm="opsi", charset="UTF-8"'}
			error = "Authentication error"
			if isinstance(err, BackendPermissionDeniedError):
				error = "Permission denied"

		elif isinstance(err, ConnectionRefusedError):
			status_code = status.HTTP_403_FORBIDDEN
			error = str(err)

		elif isinstance(err, ValidationException):
			status_code = status.HTTP_422_UNPROCESSABLE_ENTITY
			error = str(err)

		elif isinstance(err, HTTPException):
			status_code = err.status_code  # pylint: disable=no-member
			headers = err.headers  # pylint: disable=no-member
			error = err.detail

		else:
			logger.error(err, exc_info=True)
			error = str(err)

		headers = headers or {}

		if scope["type"] == "websocket":
			if isinstance(err, ConnectionClosedError):
				logger.error("Websocket connection closed with error: %s", err)
				logger.debug("Websocket connection closed with error: %s", err, exc_info=True)
				self.set_overload()
				return

			# Uvicorn (0.20.0) always closes websockets with code 403
			# There is currently no way to send a custom status code or headers
			websocket_close_code = status.WS_1008_POLICY_VIOLATION
			reason = error
			if status_code == status.HTTP_500_INTERNAL_SERVER_ERROR:
				websocket_close_code = status.WS_1011_INTERNAL_ERROR
			elif status_code == status.HTTP_503_SERVICE_UNAVAILABLE:
				websocket_close_code = status.WS_1013_TRY_AGAIN_LATER
				reason = f"{reason[:100]}\nRetry-After: {headers.get('Retry-After')}"
			# reason max length 123 bytes
			logger.debug("Closing websocket with code=%r and reason=%r", websocket_close_code, reason)
			try:
				# Need to open (accept) websocket before close
				await send({"type": "websocket.accept"})
			except RuntimeError:
				# Alread accepted
				pass
			try:
				return await send({"type": "websocket.close", "code": websocket_close_code, "reason": reason})
			except RuntimeError:
				# Alread closed (can happen on shutdown)
				pass

		if scope.get("session"):
			scope["session"].add_cookie_to_headers(headers)

		response: Optional[Response] = None
		if scope["full_path"].startswith("/rpc"):
			logger.debug("Returning jsonrpc response because path startswith /rpc")
			content = {"id": None, "result": None, "error": error}
			if scope.get("jsonrpc20"):
				content["jsonrpc"] = "2.0"
				del content["result"]
			response = JSONResponse(status_code=status_code, content=content, headers=headers)
		if not response:
			if connection.headers.get("accept") and "application/json" in connection.headers.get("accept", ""):
				logger.debug("Returning json response because of accept header")
				response = JSONResponse(status_code=status_code, content={"error": error}, headers=headers)
		if (
			not response
			and status_code == status.HTTP_401_UNAUTHORIZED
			and scope["full_path"]
			and scope["full_path"].lower().split("#", 1)[0].rstrip("/") in ("/admin", "/admin/grafana")
		):
			response = RedirectResponse(f"/login?redirect={scope['full_path']}", headers=headers)
		if not response:
			logger.debug("Returning plaintext response")
			response = PlainTextResponse(status_code=status_code, content=error, headers=headers)
		await response(scope, receive, send)

	async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:  # pylint: disable=too-many-locals, too-many-branches, too-many-statements
		if scope["type"] == "lifespan":
			return await self.app(scope, receive, send)

		try:
			connection = HTTPConnection(scope)
			set_context({"client_address": scope["client"][0]})
			await self.handle_request(connection, receive, send)
		except Exception as err:  # pylint: disable=broad-except
			await self.handle_request_exception(err, connection, receive, send)


class SessionManager:  # pylint: disable=too-few-public-methods
	def __init__(self) -> None:
		self._session_store_interval = 30
		self._stopped = asyncio.Event()
		self._should_stop = False
		self._manager_task: asyncio.Task | None = None
		self.sessions: dict[str, OPSISession] = {}

	async def stop(self, wait: bool = False) -> None:
		self._should_stop = True
		if wait:
			await self._stopped.wait()

	async def manager_task(self) -> None:
		while not self._should_stop:  # pylint: disable=too-many-nested-blocks
			try:
				await asyncio.sleep(1.0)
				delete_session_ids = []
				for session in list(self.sessions.values()):
					if session.expired:
						logger.debug("Delete expired session: %s", session.session_id)
						await session.delete()
						delete_session_ids.append(session.session_id)
					elif session.deleted:
						logger.debug("Removing deleted session: %s", session.session_id)
						delete_session_ids.append(session.session_id)
					else:
						logger.trace("Session modifications: %s", session.modifications)
						if session.modifications:
							if set(session.modifications) - {"last_used", "messagebus_last_used"}:
								# Only last_used changed
								if time.time() >= session.last_stored + self._session_store_interval:
									await session.store(modifications_only=True)
							else:
								await session.store(modifications_only=True)

				for delete_session_id in delete_session_ids:
					if delete_session_id in self.sessions:
						del self.sessions[delete_session_id]

			except Exception as err:  # pylint: disable=broad-except
				logger.error(err, exc_info=True)
		self._stopped.set()

	async def get_session(self, client_addr: str, headers: Headers | None = None, session_id: str | None = None) -> OPSISession:
		if self._should_stop:
			raise RuntimeError("Shutting down")

		session: OPSISession | None = None
		if session_id:
			session = self.sessions.get(session_id)

		if session_id and session:
			refresh_ok = await session.refresh()
			if refresh_ok and not session.expired and session.client_addr == client_addr:
				await session.update_last_used()
			else:
				del self.sessions[session_id]
				session_id = None
				session = None

		if not session:
			session = OPSISession(client_addr=client_addr, headers=headers, session_id=session_id)
			await session.init()
			assert session.client_addr == client_addr

			if session.user_agent and session.user_agent.startswith(SESSION_UNAWARE_USER_AGENTS):
				session.persistent = False
				logger.debug("Not keeping session for client %s (%s)", client_addr, session.user_agent)
			else:
				assert session.session_id
				self.sessions[session.session_id] = session

		if headers:
			session.headers = headers

		contextvar_client_session.set(session)

		return session


class OPSISession:  # pylint: disable=too-many-instance-attributes,too-many-public-methods
	def __init__(  # pylint: disable=too-many-arguments
		self, client_addr: str, headers: Headers | None = None, session_id: str | None = None
	) -> None:
		self._headers = Headers()
		self._redis_expiration_seconds = 3600
		self._messagebus_in_use_timeout = MESSAGEBUS_IN_USE_TIMEOUT
		self._modifications: dict[str, float] = {}

		self.password: str | None = None
		self.deleted = False
		self.persistent = True
		self.last_stored = 0
		self.session_id: str | None = session_id or None

		# Attributes to be stored in redis
		self._version: str = ""
		self._client_addr = client_addr
		self._user_agent = ""
		self._max_age = int(config.session_lifetime)
		self._created = 0
		self._last_used = 0
		self._messagebus_last_used = 0
		self._username: str = ""
		self._user_groups: set[str] = set()
		self._host: Host | None = None
		self._authenticated = False
		self._is_admin = False
		self._is_read_only = False

		if headers and isinstance(headers, Headers):
			self.headers = headers

	def __repr__(self) -> str:
		return f"<{self.__class__.__name__} at {hex(id(self))} created={self.created} last_used={self.last_used}>"

	def _set_modified(self, attribute: str) -> None:
		self._modifications[attribute] = utc_time_timestamp()

	@property
	def modifications(self) -> dict[str, float]:
		return self._modifications

	@property
	def headers(self) -> Headers:
		return self._headers

	@headers.setter
	def headers(self, value: Headers | None) -> None:
		if not value:
			return
		self._headers = value
		self._user_agent = self._headers.get("user-agent") or ""
		x_opsi_session_lifetime = self._headers.get("x-opsi-session-lifetime")
		if x_opsi_session_lifetime:
			try:
				session_lifetime = int(x_opsi_session_lifetime)
				if 0 < session_lifetime <= 3600 * 24:
					logger.info("Accepting session lifetime %d from client", session_lifetime)
					self.max_age = session_lifetime
				else:
					logger.warning("Not accepting session lifetime %d from client", session_lifetime)
			except ValueError:
				logger.warning("Invalid x-opsi-session-lifetime header with value '%s' from client", x_opsi_session_lifetime)

	@property
	def redis_key(self) -> str:
		assert self.session_id
		return f"{config.redis_key('session')}:{ip_address_to_redis_key(self.client_addr)}:{self.session_id}"

	@property
	def expired(self) -> bool:
		return self.validity <= 0

	@property
	def validity(self) -> int:
		return int(self.max_age - (utc_time_timestamp() - self.last_used))

	@property
	def version(self) -> str | None:
		return self._version

	@version.setter
	def version(self, value: str) -> None:
		if self._version == value:
			return
		self._version = value
		self._set_modified("version")

	@property
	def client_addr(self) -> str:
		return self._client_addr

	@client_addr.setter
	def client_addr(self, value: str) -> None:
		if self._client_addr == value:
			return
		self._client_addr = value
		self._set_modified("client_addr")

	@property
	def user_agent(self) -> str:
		return self._user_agent

	@user_agent.setter
	def user_agent(self, value: str) -> None:
		if self._user_agent == value:
			return
		self._user_agent = value
		self._set_modified("user_agent")

	@property
	def created(self) -> int:
		return self._created

	@created.setter
	def created(self, value: int) -> None:
		value = int(value)
		if self._created == value:
			return
		self._created = value
		self._set_modified("created")

	@property
	def last_used(self) -> int:
		return self._last_used

	@last_used.setter
	def last_used(self, value: int) -> None:
		value = int(value)
		if self._last_used == value:
			return
		self._last_used = value
		self._set_modified("last_used")

	@property
	def messagebus_last_used(self) -> int:
		return self._messagebus_last_used

	@messagebus_last_used.setter
	def messagebus_last_used(self, value: int) -> None:
		value = int(value)
		if self._messagebus_last_used == value:
			return
		self._messagebus_last_used = value
		self._set_modified("messagebus_last_used")

	@property
	def username(self) -> str:
		return self._username

	@username.setter
	def username(self, value: str) -> None:
		if self._username == value:
			return
		self._username = value
		self._set_modified("username")

	@property
	def user_groups(self) -> set[str]:
		return self._user_groups

	@user_groups.setter
	def user_groups(self, value: set[str]) -> None:
		if self._user_groups == value:
			return
		self._user_groups = value
		self._set_modified("user_groups")

	@property
	def host(self) -> Host | None:
		return self._host

	@host.setter
	def host(self, value: Host | None) -> None:
		if self._host == value:
			return
		self._host = value
		self._set_modified("host")

	@property
	def authenticated(self) -> bool:
		return self._authenticated

	@authenticated.setter
	def authenticated(self, value: bool) -> None:
		value = bool(value)
		if self._authenticated == value:
			return
		self._authenticated = value
		self._set_modified("authenticated")

	@property
	def is_admin(self) -> bool:
		return self._is_admin

	@is_admin.setter
	def is_admin(self, value: bool) -> None:
		value = bool(value)
		if self._is_admin == value:
			return
		self._is_admin = value
		self._set_modified("is_admin")

	@property
	def is_read_only(self) -> bool:
		return self._is_read_only

	@is_read_only.setter
	def is_read_only(self, value: bool) -> None:
		value = bool(value)
		if self._is_read_only == value:
			return
		self._is_read_only = value
		self._set_modified("is_read_only")

	@property
	def max_age(self) -> int:
		return self._max_age

	@max_age.setter
	def max_age(self, value: int) -> None:
		value = int(value)
		if self._max_age == value:
			return
		self._max_age = value
		self._set_modified("max_age")

	def _reset_auth_data(self) -> None:
		self.username = ""
		self.password = None
		self.user_groups = set()
		self.host = None
		self.authenticated = False
		self.is_admin = False
		self.is_read_only = False

	def _init_new_session(self) -> None:
		"""Generate a new session id if number of client sessions is less than max client sessions."""
		self._reset_auth_data()

		max_session_per_ip = config.max_session_per_ip
		if config.max_sessions_excludes and self.client_addr in config.max_sessions_excludes:
			logger.debug("Disable max_session_per_ip for address: %s", self.client_addr)
			max_session_per_ip = 0
		elif self.client_addr in depot_addresses:
			# Connection from a known depot server address
			if time.time() - depot_addresses[self.client_addr] <= config.session_lifetime:
				logger.debug("Disable max_session_per_ip for depot server: %s", self.client_addr)
				max_session_per_ip = 0
			else:
				# Address information is outdated
				del depot_addresses[self.client_addr]

		session_count = 0
		try:
			with redis_client() as redis:
				now = utc_time_timestamp()
				session_key = f"{config.redis_key('session')}:{ip_address_to_redis_key(self.client_addr)}:*"
				for redis_key in redis.scan_iter(session_key):
					validity = 0
					try:
						max_age = redis.hget(redis_key, b"max_age")
						if max_age:
							last_used = redis.hget(redis_key, b"last_used")
							if last_used:
								validity = int(int(max_age) - (now - int(last_used)))
					except Exception as err:  # pylint: disable=broad-except
						logger.debug(err)
					if validity > 0:
						session_count += 1
					else:
						redis.delete(redis_key)

			if max_session_per_ip > 0 and session_count + 1 > max_session_per_ip:  # pylint: disable=chained-comparison
				error = f"Too many sessions from {self.client_addr} / {self.user_agent}, maximum is: {max_session_per_ip}"
				logger.warning(error)
				raise ConnectionRefusedError(error)
		except ConnectionRefusedError as err:
			raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=str(err)) from err

		self.session_id = str(uuid.uuid4()).replace("-", "")
		self.version = str(uuid.uuid4())
		self.created = int(utc_time_timestamp())
		logger.confidential("Generated a new session id %s for %s / %s", self.session_id, self.client_addr, self.user_agent)

	async def init_new_session(self) -> None:
		await run_in_threadpool(self._init_new_session)

	async def init(self) -> None:
		if self.session_id is None:
			logger.debug("Session id missing (%s / %s)", self.client_addr, self.user_agent)
			await self.init_new_session()
		else:
			if await self.load():
				if self.expired:
					logger.debug("Session expired: %s (%s / %s)", self, self.client_addr, self.user_agent)
					await self.init_new_session()
				else:
					logger.debug("Reusing session: %s (%s / %s)", self, self.client_addr, self.user_agent)
			else:
				logger.debug("Session not found: %s (%s / %s)", self, self.client_addr, self.user_agent)
				await self.init_new_session()
		await self.update_last_used()

	def serialize(self) -> dict[str, float | int | str | bytes]:
		ser = {}
		for attribute in (
			"version",
			"client_addr",
			"user_agent",
			"max_age",
			"created",
			"last_used",
			"messagebus_last_used",
			"username",
			"user_groups",
			"host",
			"authenticated",
			"is_admin",
			"is_read_only",
		):
			val = getattr(self, f"_{attribute}")
			if isinstance(val, Host):
				val = msgspec.msgpack.encode(val.to_hash())
			elif isinstance(val, set):
				val = msgspec.msgpack.encode(list(val))
			elif isinstance(val, bool):
				val = int(val)
			elif isinstance(val, str):
				val = val.encode("utf-8")
			elif val is None:
				val = b""
			ser[attribute] = val
		return ser

	@classmethod
	def deserialize(cls, data: dict[str | bytes, float | int | bytes | str]) -> dict[str, Any]:
		des = {}
		for attr, val in data.items():
			if isinstance(attr, bytes):
				attr = attr.decode("utf-8")
			if attr == "host":
				if val:
					assert isinstance(val, bytes)
					val = Host.fromHash(msgspec.msgpack.decode(val))  # type: ignore
				else:
					val = None  # type: ignore
			elif attr == "user_groups":
				val = set(msgspec.msgpack.decode(val))  # type: ignore
			elif attr in ("authenticated", "is_admin", "is_read_only"):
				val = bool(int(val))
			elif isinstance(val, bytes):
				val = val.decode("utf-8")
			des[attr] = val
		return des

	@classmethod
	def from_serialized(cls, data: dict[str, float | int | bytes | str]) -> OPSISession:
		data = cls.deserialize(data)  # type: ignore
		obj = cls(data["client_addr"])  # type: ignore
		for attr, val in data.items():
			setattr(obj, attr, val)
		return obj

	def get_cookie(self) -> Optional[str]:
		if not self.session_id or not self.persistent:
			return None
		attrs = "; ".join(SESSION_COOKIE_ATTRIBUTES)
		if attrs:
			attrs += "; "

		# A zero or negative number will expire the cookie immediately
		max_age = f"; Max-Age={self.max_age}"
		if self.deleted:
			max_age = "; Max-Age=0"
		if self.in_use_by_messagebus:
			# Session cookie
			max_age = ""
		return f"{SESSION_COOKIE_NAME}={self.session_id}; {attrs}path=/{max_age}"

	def add_cookie_to_headers(self, headers: dict[str, str]) -> None:
		cookie = self.get_cookie()
		# Keep current set-cookie header if already set
		if cookie and "set-cookie" not in headers:
			headers["set-cookie"] = cookie

	async def update_last_used(self) -> None:
		self.last_used = int(utc_time_timestamp())

	async def update_messagebus_last_used(self) -> None:
		self.last_used = self.messagebus_last_used = int(utc_time_timestamp())

	@property
	def in_use_by_messagebus(self) -> bool:
		return int(utc_time_timestamp()) - self._messagebus_last_used < self._messagebus_in_use_timeout

	def _refresh(self) -> bool:
		with redis_client() as redis:
			version = redis.hget(self.redis_key, b"version")
			if not version:
				# Deleted
				return False
		version_str = version.decode("utf-8")
		if version_str == self.version:
			logger.debug("Version %s unchanged, cache up-to-date", self.version)
			return True
		logger.debug("Version %s changed to %s, reload", self.version, version_str)
		return self._load()

	async def refresh(self) -> bool:
		# aioredis is sometimes slow ~300ms load, using redis for now
		return await run_in_threadpool(self._refresh)

	def _load(self) -> bool:
		logger.debug("Load session")
		data = {}
		with redis_client() as redis:
			try:
				data = self.deserialize(redis.hgetall(self.redis_key))
			except Exception as err:  # pylint: disable=broad-except
				logger.warning("Failed to load session: %s (%s / %s)", err, self.client_addr, self.user_agent)

		if not data:
			return False

		for attr, val in data.items():
			try:
				setattr(self, attr, val)
			except AttributeError:
				pass

		if not self.last_stored:
			self.last_stored = int(utc_time_timestamp())

		self._modifications = {}
		return True

	async def load(self) -> bool:
		# aioredis is sometimes slow ~300ms load, using redis for now
		return await run_in_threadpool(self._load)

	def _store(self, modifications_only: bool = False) -> None:
		if self.deleted or self.expired or not self.persistent:
			return
		if modifications_only and not self._modifications:
			return
		logger.debug("Store session")
		self.version = str(uuid.uuid4())
		self.last_stored = int(utc_time_timestamp())
		# Remember that the session data in redis may have been
		# changed by another worker process since the last load.
		with redis_client() as redis:
			data = self.serialize()
			if modifications_only and redis.exists(self.redis_key):
				data = {a: v for a, v in data.items() if a in self._modifications}
			if data:
				with redis.pipeline() as pipe:
					pipe.hset(self.redis_key, mapping=data)  # type: ignore
					pipe.expire(self.redis_key, self._redis_expiration_seconds)
					pipe.execute()

		self._modifications = {}

	async def store(self, wait: bool = True, modifications_only: bool = False) -> None:
		# aioredis is sometimes slow ~300ms load, using redis for now
		task = run_in_threadpool(self._store, modifications_only)
		if wait:
			await task
		else:
			asyncio_create_task(task)

	def sync_delete(self) -> None:
		logger.debug("Delete session")
		with redis_client() as redis:
			for _ in range(10):
				redis.delete(self.redis_key)
				time_sleep(0.01)
				# Be sure to delete key
				if not redis.exists(self.redis_key):
					break
		self.deleted = True

	async def delete(self) -> None:
		return await run_in_threadpool(self.sync_delete)


auth_module: AuthenticationModule | None = None  # pylint: disable=invalid-name


def get_auth_module() -> AuthenticationModule:
	global auth_module  # pylint: disable=invalid-name,global-statement

	if not auth_module:
		try:
			ldap_conf = opsi_config.get("ldap_auth")
			if ldap_conf["ldap_url"]:
				logger.debug("Using LDAP auth with config: %s", ldap_conf)
				if "directory-connector" in get_unprotected_backend().available_modules:
					auth_module = LDAPAuthentication(**ldap_conf)
				else:
					logger.error("Disabling LDAP authentication: directory-connector module not available")
		except Exception as err:  # pylint: disable=broad-except
			logger.debug(err)

		if not auth_module:
			auth_module = PAMAuthentication()

	return auth_module.get_instance()


async def authenticate_host(scope: Scope) -> None:  # pylint: disable=too-many-branches,too-many-statements
	session = scope["session"]
	backend = get_unprotected_backend()

	hosts = []
	host_filter = {}
	if config.allow_host_key_only_auth:
		session.username = "<host-key-only-auth>"
		logger.debug("Trying to authenticate host by opsi host key only")
		host_filter["opsiHostKey"] = session.password
	elif re.search(r"^[a-fA-F0-9]{2}(:[a-fA-F0-9]{2}){5}$", session.username):
		logger.debug("Trying to authenticate host by mac address and opsi host key")
		host_filter["hardwareAddress"] = session.username
	else:
		logger.debug("Trying to authenticate host by host id and opsi host key")
		session.username = session.username.rstrip(".")
		host_filter["id"] = session.username

	hosts = await backend.async_call("host_getObjects", **host_filter)
	if not hosts:
		raise BackendAuthenticationError(f"Host not found '{session.username}'")
	if len(hosts) > 1:
		raise BackendAuthenticationError(f"More than one matching host object found '{session.username}'")
	host = hosts[0]
	if not host.opsiHostKey:
		raise BackendAuthenticationError(f"OpsiHostKey missing for host '{host.id}'")

	logger.confidential(
		"Host '%s' authentication: password sent '%s', host key '%s', onetime password '%s'",
		host.id,
		session.password,
		host.opsiHostKey,
		host.oneTimePassword if host.getType() == "OpsiClient" else "n.a.",
	)

	if host.opsiHostKey and session.password == host.opsiHostKey:
		logger.info("Host '%s' authenticated by host key", host.id)
	elif isinstance(host, OpsiClient) and host.oneTimePassword and session.password == host.oneTimePassword:
		logger.info("Host '%s' authenticated by onetime password", host.id)
		host.oneTimePassword = ""
		# Update immediately
		await backend.async_call("host_updateObject", host=host)
	else:
		raise BackendAuthenticationError(f"Authentication of host '{host.id}' failed")

	session.host = host
	session.authenticated = True
	session.is_read_only = False
	session.is_admin = host.getType() in ("OpsiConfigserver", "OpsiDepotserver")
	if session.username != host.id:
		session.username = host.id
		if not scope.get("response-headers"):
			scope["response-headers"] = {}
		scope["response-headers"]["x-opsi-new-host-id"] = session.username

	if host.getType() == "OpsiClient":
		logger.info("OpsiClient authenticated, updating host object")
		host.setLastSeen(timestamp())
		if config.update_ip and session.client_addr not in (None, "127.0.0.1", "::1", host.ipAddress):
			host.setIpAddress(session.client_addr)
		else:
			# Value None on update means no change!
			host.ipAddress = None
		await backend.async_call("host_updateObject", host=host)

	elif host.getType() in ("OpsiConfigserver", "OpsiDepotserver"):
		logger.debug("Storing depot server address: %s", session.client_addr)
		depot_addresses[session.client_addr] = time.time()


async def authenticate_user_passwd(scope: Scope) -> None:
	session = scope["session"]
	backend = get_unprotected_backend()
	credentials = await backend.async_call("user_getCredentials", username=session.username)
	if credentials and session.password == credentials.get("password"):
		session.authenticated = True
		session.is_read_only = False
		session.is_admin = False
	else:
		raise BackendAuthenticationError(f"Authentication failed for user {session.username}")


async def authenticate_user_auth_module(scope: Scope) -> None:
	session = scope["session"]
	authm = get_auth_module()

	if not authm:
		raise BackendAuthenticationError("Authentication module unavailable")

	logger.debug("Trying to authenticate by user authentication module %s", authm)

	try:
		await run_in_threadpool(authm.authenticate, session.username, session.password)
	except Exception as err:
		raise BackendAuthenticationError(f"Authentication failed for user '{session.username}': {err}") from err

	# Authentication did not throw exception => authentication successful
	session.authenticated = True
	session.user_groups = authm.get_groupnames(session.username)
	session.is_admin = authm.user_is_admin(session.username)
	session.is_read_only = authm.user_is_read_only(session.username)

	if session.is_admin:
		create_user(session.username, session.user_groups)

	logger.info(
		"Authentication successful for user '%s', groups '%s', admin group is '%s', admin: %s, readonly groups %s, readonly: %s",
		session.username,
		",".join(session.user_groups),
		authm.get_admin_groupname(),
		session.is_admin,
		authm.get_read_only_groupnames(),
		session.is_read_only,
	)


async def authenticate(scope: Scope, username: str, password: str, mfa_otp: str | None = None) -> None:
	try:
		await _authenticate(scope, username, password, mfa_otp)
	except BackendAuthenticationError:
		cmd = (
			f"ts.add {config.redis_key('stats')}:client:failed_auth:{ip_address_to_redis_key(scope['client'][0])} "
			f"* 1 RETENTION 86400000 LABELS client_addr {scope['client'][0]}"
		)
		logger.trace(cmd)
		redis = await async_redis_client()
		await redis.execute_command(cmd)  # type: ignore[no-untyped-call]
		await asyncio.sleep(0.2)
		raise


async def _authenticate(  # pylint: disable=unused-argument,too-many-branches,too-many-statements
	scope: Scope, username: str, password: str, mfa_otp: str | None = None
) -> None:
	headers = Headers(scope=scope)
	if not scope["session"]:
		addr = scope["client"]
		scope["session"] = await session_manager.get_session(client_addr=addr[0], headers=headers)
	session = scope["session"]
	session.authenticated = False

	await check_min_configed_version(session.user_agent)
	# Check if client address is blocked
	await check_blocked(session.client_addr)

	username = session.username = (username or "").lower()
	password = session.password = password or ""

	logger.info("Start authentication of client %s", session.client_addr)

	if not session.password:
		raise BackendAuthenticationError("No password specified")

	if session.username == config.monitoring_user:
		await authenticate_user_passwd(scope=scope)
	elif (
		re.search(r"^[^.]+\.[^.]+\.\S+$", session.username)
		or re.search(r"^[a-fA-F0-9]{2}(:[a-fA-F0-9]{2}){5}$", session.username)
		or not session.username
	):
		await authenticate_host(scope=scope)
	else:
		if config.multi_factor_auth in ("totp_optional", "totp_mandatory"):
			if not mfa_otp:
				mfa_otp = headers.get("x-opsi-mfa-otp")
			if not mfa_otp:
				match = re.search(r"^(.+)(\d{6})$", session.password)
				if match:
					logger.info("Assuming that TOTP is attached to password")
					session.password = match.group(1)
					secret_filter.add_secrets(session.password)
					mfa_otp = match.group(2)

		backend = get_unprotected_backend()
		now = timestamp()
		users = await backend.async_call("user_getObjects", id=session.username)
		if users:
			user = users[0]
		else:
			user = User(id=username, created=now)
			await backend.async_call("user_insertObject", user=user)

		if config.multi_factor_auth in ("totp_optional", "totp_mandatory"):
			if config.multi_factor_auth == "totp_mandatory" or user.mfaState == "totp_active":
				if not user.otpSecret:
					raise BackendAuthenticationError("MFA OTP configuration error")
				if not mfa_otp:
					raise BackendAuthenticationError("MFA one-time password missing")
				totp = pyotp.TOTP(user.otpSecret)
				if not totp.verify(mfa_otp):
					raise BackendAuthenticationError("Incorrect one-time password")
				logger.info("OTP MFA successful")

		await authenticate_user_auth_module(scope=scope)

		user.lastLogin = now
		await backend.async_call("user_updateObject", user=user)

	await session.store(wait=True)

	if not session.username or not session.authenticated:
		raise BackendPermissionDeniedError("Not authenticated")

	logger.debug("Client %s authenticated, username: %s", session.client_addr, session.username)

	await check_admin_networks(session)


async def check_admin_networks(session: OPSISession) -> None:
	if not session.is_admin or not config.admin_networks:
		return

	is_admin_network = False
	for network in config.admin_networks:
		if ip_address_in_network(session.client_addr, network):
			is_admin_network = True
			break

	if not is_admin_network:
		logger.warning(
			"User '%s' from '%s' not in admin network '%s'",
			session.username,
			session.client_addr,
			config.admin_networks,
		)
		session.is_admin = False
		admin_group = opsi_config.get("groups", "admingroup")
		if admin_group in session.user_groups:
			# Remove admin group from groups because acl.conf currently does not support is_admin
			session.user_groups.remove(admin_group)


async def check_blocked(ip_address: str) -> None:
	logger.info("Checking if client '%s' is blocked", ip_address)
	redis = await async_redis_client()
	is_blocked = bool(await redis.get(f"{config.redis_key('stats')}:client:blocked:{ip_address_to_redis_key(ip_address)}"))
	if is_blocked:
		logger.info("Client '%s' is blocked", ip_address)
		raise ConnectionRefusedError(f"Client '{ip_address}' is blocked")

	now = round(time.time()) * 1000
	cmd = (
		f"ts.range {config.redis_key('stats')}:client:failed_auth:{ip_address_to_redis_key(ip_address)} "
		f"{(now-(config.auth_failures_interval*1000))} {now} aggregation count {(config.auth_failures_interval*1000)}"
	)
	logger.debug(cmd)
	try:
		data = await redis.execute_command(cmd)  # type: ignore[no-untyped-call]
		num_failed_auth = int(data[-1][1])
		logger.debug("num_failed_auth: %s", num_failed_auth)
	except RedisResponseError as err:
		num_failed_auth = 0
		if "key does not exist" not in str(err):
			raise
	except IndexError as err:
		logger.debug(err)
		num_failed_auth = 0
	if num_failed_auth >= config.max_auth_failures:
		is_blocked = True
		logger.warning("Blocking client '%s' for %0.2f minutes", ip_address, (config.client_block_time / 60))
		await redis.setex(f"{config.redis_key('stats')}:client:blocked:{ip_address_to_redis_key(ip_address)}", config.client_block_time, 1)


async def check_network(client_addr: str) -> None:
	if not config.networks:
		return
	for network in config.networks:
		if ip_address_in_network(client_addr, network):
			return
	raise ConnectionRefusedError(f"Host '{client_addr}' is not allowed to connect")


async def check_min_configed_version(user_agent: str) -> None:
	if not config.min_configed_version or not user_agent or "opsi config editor" not in user_agent:
		return

	configed_version = None
	try:
		configed_version = Version(user_agent.rsplit()[-1])
	except ValueError as err:
		logger.debug(err)

	if not configed_version or configed_version < config.min_configed_version:
		raise ConnectionRefusedError(
			f"Configed {(str(configed_version) if configed_version else user_agent)} "
			f"is not allowed to connect (min-configed-version: {str(config.min_configed_version)})"
		)


async def check_access(connection: HTTPConnection) -> None:
	scope = connection.scope
	if scope["required_access_role"] == ACCESS_ROLE_PUBLIC:
		return

	session = connection.scope["session"]

	if not session.username or not session.authenticated:
		auth = get_basic_auth(connection.headers)
		await authenticate(connection.scope, auth.username, auth.password)

	if scope["required_access_role"] == ACCESS_ROLE_ADMIN and not session.is_admin:
		raise BackendPermissionDeniedError(f"Not an admin user '{session.username}' {scope.get('method')} {scope.get('path')}")


session_manager = SessionManager()
