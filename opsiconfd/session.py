# -*- coding: utf-8 -*-

# This file is part of opsi.
# Copyright (C) 2020 uib GmbH <info@uib.de>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
:copyright: uib GmbH <info@uib.de>
:author: Jan Schneider <j.schneider@uib.de>
:license: GNU Affero General Public License version 3

https://github.com/tiangolo/fastapi/blob/master/docs/tutorial/middleware.md

You can add middleware to FastAPI applications.

A "middleware" is a function that works with every request before it is processed by any specific path operation.
And also with every response before returning it.

    It takes each request that comes to your application.
    It can then do something to that request or run any needed code.
    Then it passes the request to be processed by the rest of the application (by some path operation).
    It then takes the response generated by the application (by some path operation).
    It can do something to that response or run any needed code.
    Then it returns the response.
"""

import typing
import uuid
import base64
import datetime
import contextvars
import orjson
from collections import namedtuple
from typing import List

from fastapi import HTTPException, status
from fastapi.responses import PlainTextResponse, JSONResponse
from starlette.datastructures import MutableHeaders
from starlette.requests import HTTPConnection
#from starlette.sessions import CookieBackend, Session, SessionBackend
from starlette.types import ASGIApp, Message, Receive, Scope, Send

from OPSI.Backend.Manager.AccessControl import UserStore
from OPSI.Util import serialize, deserialize, ipAddressInNetwork

from .logging import logger, secret_filter
from .worker import get_redis_client, contextvar_client_session
from .backend import get_client_backend
from .config import config

BasicAuth = namedtuple("BasicAuth", ["username", "password"])
def get_basic_auth(headers):
	auth_header = None
	for (k, v) in headers:
		if (k.lower() == b'authorization'):
			auth_header = v
			break
	#auth_header = headers.get('Authorization')
	if not auth_header:
		raise HTTPException(
			status_code=status.HTTP_401_UNAUTHORIZED,
			detail="Authorization header missing",
			headers={"WWW-Authenticate": 'Basic realm="opsi", charset="UTF-8"'}
		)

	if not auth_header.startswith(b'Basic '):
		raise HTTPException(
			status_code=status.HTTP_401_UNAUTHORIZED,
			detail="Authorization method unsupported",
			headers={"WWW-Authenticate": 'Basic realm="opsi", charset="UTF-8"'}
		)

	encoded_auth = auth_header[6:] # Stripping "Basic "
	auth = base64.decodebytes(encoded_auth).decode('utf-8')
	(username, password) = auth.rsplit(':', 1)

	secret_filter.add_secrets(password)

	return BasicAuth(username, password)

def get_session_from_context():
	try:
		return contextvar_client_session.get()
	except LookupError as exc:
		logger.debug("Failed to get session from context: {0}", exc)

class SessionMiddleware:
	def __init__(self, app: ASGIApp, public_path: List[str] = []) -> None:
		self.app = app
		self.session_cookie = 'opsiconfd-session'
		self.max_age = 120  # in seconds
		#self.security_flags = "httponly; samesite=lax; secure"
		self.security_flags = ""
		self._public_path = public_path

	async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
		logger.trace(f"SessionMiddleware {scope}")
		try:
			
			if scope["type"] not in ("http", "websocket"):
				await self.app(scope, receive, send)
				return

			is_public = False
			for p in self._public_path:
				if scope["path"].startswith(f"{p}/"):
					is_public = True

			connection = HTTPConnection(scope)
			session_id = connection.cookies.get(self.session_cookie, None)

			scope["session"] = session = OPSISession(self, session_id)
			await session.init()
			contextvar_client_session.set(session)
					
			if not is_public and (not session.user_store.username or not session.user_store.authenticated):
				auth = get_basic_auth(scope['headers'])
				try:
					
					get_client_backend().backendAccessControl.authenticate(auth.username, auth.password)
					
					if not session.user_store.host:
						if not session.user_store.isAdmin:
							raise Exception(f"Not an admin user '{session.user_store.username}'")
						
						if config.admin_networks:
							is_admin_network = False
							for network in config.admin_networks:
								ip_adress_in_network = ipAddressInNetwork(connection.client.host,network)							
								if ip_adress_in_network:
									is_admin_network = ip_adress_in_network
									break

						if not is_admin_network:
							raise Exception(f"User not in admin network '{config.admin_networks}'")
				except Exception as e:
					logger.warning(e)
			
					raise HTTPException(
						status_code=status.HTTP_401_UNAUTHORIZED,
						detail=str(e),
						headers={"WWW-Authenticate": 'Basic realm="opsi", charset="UTF-8"'}
					)
			
			async def send_wrapper(message: Message) -> None:
				await session.store()
				if message["type"] == "http.response.start":
					headers = MutableHeaders(scope=message)
					cookie = f"%s=%s; path=/; Max-Age=%d" % (
						self.session_cookie,
						session.session_id,
						self.max_age
					)
					headers.append("Set-Cookie", cookie)
				await send(message)

			await self.app(scope, receive, send_wrapper)
		except HTTPException as e:
			response = None
			if scope["path"].startswith("/rpc"):
				logger.debug("Auth error - returning jsonrpc response")
				response = JSONResponse(
					status_code=e.status_code,
					content={"jsonrpc": "2.0", "id": None, "result": None, "error": e.detail},
					headers=e.headers
				)
			if not response:
				for k, v in scope['headers']:
					if k == b"accept" and b"application/json" in v:
						logger.debug("Auth error - returning json response")
						response = JSONResponse(
							status_code=e.status_code,
							content={"error": e.detail},
							headers=e.headers
						)
			if not response:
				logger.debug("Auth error - returning plaintext response")
				response = PlainTextResponse(
					status_code=e.status_code,
					content=e.detail,
					headers=e.headers
				)
			await response(scope, receive, send)


class OPSISession():
	def __init__(self, session_middelware: SessionMiddleware, session_id: str = None) -> None:
		self._session_middelware = session_middelware
		self.session_id = session_id
		self.created = 0
		self.last_used = 0
		self.user_store = UserStore()
		self.option_store = {}
		self._data: typing.Dict[str, typing.Any] = {}
		#self._redis = redis_connection()

	def __repr__(self):
		return f"<{self.__class__.__name__} created={self.created} last_used={self.last_used}>"

	@classmethod
	def utc_time_timestamp(cls):
		dt = datetime.datetime.now()
		utc_time = dt.replace(tzinfo=datetime.timezone.utc) 
		return utc_time.timestamp()

	@property
	def max_age(self):
		return self._session_middelware.max_age

	@property
	def session_cookie(self):
		return self._session_middelware.session_cookie

	@property
	def redis_key(self) -> str:
		assert self.session_id
		return f"{self.session_cookie}_{self.session_id}"

	@property
	def expired(self) -> bool:
		return self.utc_time_timestamp() - self.last_used > self.max_age

	async def init(self) -> str:
		if self.session_id is None:
			await self.generate_id()
		else:
			if await self.load():
				if self.expired:
					logger.debug(f"session expired: {self}")
					await self.generate_id()
				else:
					logger.debug(f"Reusing session: {self}")
			else:
				logger.debug(f"Session not found: {self}")
				await self.generate_id()

		if not self.created:
			self.created = self.utc_time_timestamp()
		self._update_last_used()
		await self.store()

	async def generate_id(self) -> str:
		"""Generate a new session id."""
		self.session_id = str(uuid.uuid4()).replace("-", "")
		logger.debug(f"Generated a new session id: {self.session_id}")

	async def load(self) -> bool:
		self._data = {}
		client = await get_redis_client()
		data = await client.get(self.redis_key)
		if not data:
			return False
		data = orjson.loads(data)
		self.created = data.get("created", self.created)
		self.last_used = data.get("last_used", self.last_used)
		for k, v in data.get("user_store", {}).items():
			setattr(self.user_store, k, deserialize(v))
		self.option_store = data.get("option_store", self.option_store)
		self._data = data.get("data", self._data)
		return True

	async def store(self) -> None:
		data = {
			"created": self.created,
			"last_used": self.last_used,
			"user_store": serialize(self.user_store.__dict__),
			"option_store": self.option_store,
			"data": self._data
		}
		# Set is not serializable
		if "userGroups" in data["user_store"]:
			data["user_store"]["userGroups"] = list(data["user_store"]["userGroups"])
		# Do not store password
		if "password" in data["user_store"]:
			del data["user_store"]["password"]
		client = await get_redis_client()
		await client.set(self.redis_key, orjson.dumps(data), ex=self.max_age)

	def _update_last_used(self):
		self.last_used = self.utc_time_timestamp()

	def get(self, name: str, default: typing.Any = None) -> typing.Any:
		return self._data.get(name, default)

	def set(self, key: str, value: typing.Any) -> None:
		self._data[key] = value
