#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
   = = = = = = = = = = = = = = = = = = = = = = =
   =   opsi configuration daemon (opsiconfd)   =
   = = = = = = = = = = = = = = = = = = = = = = =
   
   opsiconfd is part of the desktop management solution opsi
   (open pc server integration) http://www.opsi.org
   
   Copyright (C) 2008 uib GmbH
   
   http://www.uib.de/
   
   All rights reserved.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License version 2 as
   published by the Free Software Foundation.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   
   @copyright:	uib GmbH <info@uib.de>
   @author: Jan Schneider <j.schneider@uib.de>
   @license: GNU General Public License version 2
"""

__version__ = '3.4.99'

# Imports
import os, sys, getopt, threading, time, socket
from OpenSSL import SSL
from signal import *

# Twisted imports
from twisted.internet import defer, threads, reactor
from twisted.python.failure import Failure
from twisted.python import log
from OPSI.web2 import resource, stream, server, http, responsecode
from OPSI.web2.http_headers import Cookie
from OPSI.web2.channel.http import HTTPFactory
from OPSI.web2.dav import static

# OPSI imports
from OPSI.Logger import *
from OPSI.Util.File import IniFile
from OPSI.Types import *
from OPSI.System import which, execute, getDiskSpaceUsage
from OPSI.Backend.BackendManager import BackendManager
from OPSI import Tools

logger = Logger()
logger.setConsoleLevel(100)


infoPage = u'''
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>opsiconfd info</title>
	<style>
	a:link 	  { color: #555555; text-decoration: none; }
	a:visited { color: #555555; text-decoration: none; }
	a:hover	  { color: #46547f; text-decoration: none; }
	a:active  { color: #555555; text-decoration: none; }
	body      { font-family: verdana, arial; font-size: 12px; }
	#title    { padding: 10px; color: #6276a0; font-size: 20px; letter-spacing: 5px; }
	#infos    { padding: 50px; color: #555555; font-size: 14px; }
	#info     { padding-bottom: 20px }
	h1        { font-size: 14px; font-weight; bold; letter-spacing: 2px; }
	table     { table-layout: auto; background-color: #fafafa; }
	td, th    { font-size: 12px; border: 1px #6276a0 solid; text-align: left; padding: 2px 10px 2px 10px; }
	th        { color: #eeeeee; background-color: #6276a0; }
	</style>
</head>
<body>
	<span id="title">
		<img src="opsi_logo.png" />
		<span sytle="padding: 1px">opsiconfd info</span>
	</span>
	<div id="infos">
		<div id="info">%time%</div>
		<div id="info">%config_info%</div>
		<div id="info">%thread_info%</div>
		<div id="info">%session_info%</div>
		<div id="info">%disk_usage_info%</div>
	<div>
</body>
'''
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                        CLASS WORKER                                               =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class Worker:
	def __init__(self, opsiconfd, request, resource, method = 'POST'):
		self.opsiconfd = opsiconfd
		self.request   = request
		self.resource  = resource
		self.method    = method
		self.session   = None
		self.response  = http.Response()
		self.result    = ""
		self.deferred  = None
		self._setLogFile()
	
	def process(self):
		logger.info("Worker %s started processing" % self)
		try:
			self.deferred = defer.Deferred()
			self.deferred.addCallback(self._getSession)
			self.deferred.addCallback(self._linkLogFile)
			self.deferred.addCallback(self._setResult)
			self.deferred.addCallback(self._freeSession)
			self.deferred.addCallback(self._returnResponse)
			self.deferred.addErrback(self._returnError)
			self.deferred.callback(None)
			return self.deferred
		except Exception, e:
			return self._returnError(e)
	
	def _returnResponse(self, result):
		logger.debug2("%s._returnResponse" % self.__class__.__name__)
		self.response.code   = responsecode.OK
		self.response.stream = stream.IByteStream(self.result)
		return self.response
	
	def _returnError(self, failure):
		logger.debug2("%s._returnError" % self.__class__.__name__)
		self._freeSession(failure)
		if (self.response.code == responsecode.OK):
			# Do not overwrite responsecodes set earlier
			self.response.code = responsecode.INTERNAL_SERVER_ERROR
		
		if isinstance(failure, Failure):
			self.result = failure.getErrorMessage()
			tb = failure.getTraceback()
			if type(tb) in (unicode, str):
				logger.critical(tb)
			else:
				logger.logTraceback(tb)
			
		else:
			self.result = unicode(failure)
		logger.error(u"Failed to process request: %s" % self.result)
		return self._returnResponse(None)
	
	def _setLogFile(self):
		if self.opsiconfd.config['machineLogs'] and self.opsiconfd.config['logFile']:
			logger.setLogFile( self.opsiconfd.config['logFile'].replace('%m', self.request.remoteAddr.host), object = self )
	
	def _linkLogFile(self, result):
		if self.session.hostname and self.opsiconfd.config['machineLogs'] and self.opsiconfd.config['logFile']:
			logger.linkLogFile( self.opsiconfd.config['logFile'].replace('%m', self.session.hostname), object = self )
	
	def _freeSession(self, resultOrFailure):
		logger.info(u"Freeing session %s" % self.session)
		self.session.setInUse(False)
		
	def _getSession(self, result):
		''' This method restores a session or generates a new one. '''
		self.session = None
		
		logger.confidential(u"Request headers: %s " % self.request.headers)
		
		# Get user agent
		userAgent = None
		try:
			userAgent = self.request.headers.getHeader('user-agent')
		except Exception, e:
			logger.info(u"Client '%s' did not supply user-agent" % self.request.remoteAddr.host)
		if not userAgent:
			userAgent = 'unknown'
		
		# Get session handler
		sessionHandler = self.opsiconfd.getSessionHandler()
		
		# Get session id from cookie request header
		sessionId = u''
		try:
			for cookie in self.request.headers.getHeader('cookie'):
				if (cookie.name == sessionHandler.sessionName):
					sessionId = unicode(cookie.value)
		except Exception, e:
			pass
		
		if not sessionId:
			logger.notice(u"Application '%s' on client '%s' did not send cookie" % (userAgent, self.request.remoteAddr.host))
		
		# Get Session object
		self.session = sessionHandler.getSession(sessionId)
		if (sessionId == self.session.uid):
			logger.info(u"Reusing session for client '%s', application '%s'" % (self.request.remoteAddr.host, userAgent))
		elif sessionId:
			logger.notice(u"Application '%s' on client '%s' supplied non existing session id: %s" % (userAgent, self.request.remoteAddr.host, sessionId))
		
		if self.session.ip and (self.session.ip != self.request.remoteAddr.host):
			logger.critical(u"Client ip '%s' does not match session ip '%s', deleting old session and creating a new one" \
				% (self.request.remoteAddr.host, self.session.ip) )
			sessionHandler.deleteSession(self.session.uid)
			self.session = sessionHandler.getSession()
		
		# Set ip
		self.session.ip = self.request.remoteAddr.host
		
		# Set user-agent / application
		if self.session.userAgent and (self.session.userAgent != userAgent):
			logger.warning(u"Application changed from '%s' to '%s' for existing session of client '%s'" \
				% (self.session.userAgent, userAgent, self.request.remoteAddr.host))
		self.session.userAgent = userAgent
		
		logger.confidential(u"Session id is '%s' for client '%s', application '%s'" \
			% (self.session.uid, self.request.remoteAddr.host, self.session.userAgent))
		
		# Set last modified to current time
		self.session.setInUse(True)
		
		# Add cookie to headers
		cookie = Cookie(self.session.name.encode('ascii', 'replace'), self.session.uid.encode('ascii', 'replace'), path='/')
		self.response.headers.setHeader('set-cookie', [ cookie ] )
		
		# Set user and password
		if not self.session.user and not self.session.password and self.request.headers.getHeader('Authorization'):
			(user, password) = ('', '')
			logger.debug(u"Trying to get username and password from Authorization header")
			auth = self.request.headers.getHeader('Authorization')
			if auth:
				logger.debug(u"Authorization header found (type: %s)" % auth[0])
				try:
					encoded = auth[1]
					(user, password) = base64.decodestring(encoded).split(':', 1)
					logger.confidential(u"Client supplied username '%s' and password '%s'" % (user, password))
				except Exception:
					logger.error(u"Bad Authorization header from '%s': %s" % (self.request.remoteAddr.host, e))
			
			self.session.user = user
			self.session.password = password
		
		# Set hostname
		if not self.session.hostname:
			hostname = ''
			if (self.session.user.count('.') > 2):
				hostname = self.session.user
			elif self.opsiconfd.config['resolveClientIp']:
				try:
					hostname = socket.getfqdn(self.request.remoteAddr.host).lower()
					if re.search('^\d+\.\d+\.\d+\.\d+$', hostname):
						logger.error(u"Cannot get fqdn for client '%s'" % self.request.remoteAddr.host)
						hostname = ''
					elif (hostname.count('.') == 1):
						logger.error(u"Cannot get fqdn for client '%s', got hostname '%s' only" % (self.request.remoteAddr.host, hostname))
						hostname = ''
				except Exception, e:
					logger.warning(u"Failed to resolve address '%s': %s" % (self.request.remoteAddr.host, e))
			if hostname:
				logger.info(u"Storing hostname '%s' in session" % hostname)
				self.session.hostname = hostname
			else:
				logger.warning(u"Failed to get hostname for client '%s'" % self.request.remoteAddr.host,)
		
		
		logger.confidential(u"Session content: %s" % self.session.__dict__)



# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                  CLASS WORKER OPSI JSON RPC                                       =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class WorkerOpsiJsonRpc(Worker):
	def __init__(self, opsiconfd, request, resource, method = 'POST'):
		Worker.__init__(self, opsiconfd, request, resource, method)
		#self.rpc = {"id": None, "method": None, "params": []}
		#self.result = {"id": None, "result": None, "error": None}
	
	def process(self):
		logger.info("Worker %s started processing" % self)
		try:
			self.deferred = defer.Deferred()
			self.deferred.addCallback(self._getSession)
			self.deferred.addCallback(self._linkLogFile)
			#self.deferred.addCallback(self._getQuery)
			#self.deferred.addCallback(self._getRpc)
			#self.deferred.addCallback(self._authenticate)
			#self.deferred.addCallback(self._executeRpc)
			## Convert ints to strings to prevent problems with delphi libraries
			self.deferred.addCallback(self._freeSession)
			self.deferred.addCallback(self._returnResponse)
			self.deferred.addErrback(self._freeSession)
			self.deferred.addErrback(self._returnError)
			self.deferred.callback(None)
			return self.deferred
		except Exception, e:
			return self._returnError(e)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                               CLASS WORKER OPSI JSON INTERFACE                                    =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class WorkerOpsiJsonInterface(WorkerOpsiJsonRpc):
	def __init__(self, opsiconfd, request, resource, method = 'POST'):
		WorkerOpsiJsonRpc.__init__(self, opsiconfd, request, resource, method)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                 CLASS WORKER OPSICONFD INFO                                       =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class WorkerOpsiconfdInfo(Worker):
	def __init__(self, opsiconfd, request, resource, method = 'POST'):
		Worker.__init__(self, opsiconfd, request, resource, method)

	def _setResult(self, result):
		logger.info(u"Creating opsiconfd info page")
		
		configInfo  = u'<h1>Server config</h1>'
		configInfo += u'<table>'
		configInfo += u'<tr><th>key</th><th>value</th></tr>'
		keys = self.opsiconfd.config.keys()
		keys.sort()
		for key in keys:
			if key in ('staticDirectories'):
				continue
			configInfo += u'<tr><td>%s</td><td>%s</td>' % (key, self.opsiconfd.config[key])
		configInfo += u'</table>'
		
		threads = []
		for thread in threading.enumerate():
			threads.append(thread)
		threadInfo  = u'<h1>Running threads (%d)</h1>' % len(threads)
		threadInfo += u'<table>'
		threadInfo += u'<tr><th>class</th><th>name</th><th>ident</th><th>alive</th></tr>'
		for thread in threads:
			threadInfo += u'<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>' % (thread.__class__.__name__, thread.name, thread.ident, thread.isAlive())
		threadInfo += u'</table>'
		
		sessions = self.opsiconfd.getSessionHandler().getSessions()
		sessionInfo  = u'<h1>Active sessions (%d)</h1>' % len(sessions.keys())
		sessionInfo += u'<table>'
		sessionInfo += u'<tr><th>created</th><th>last modified</th><th>ip</th><th>hostname</th><th>user</th><th>in use</th><th>application</th></tr>'
		for session in sessions.values():
			sessionInfo += u'<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>' \
				% (time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(session.created)), time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(session.lastModified)), \
					session.ip, session.hostname, session.user, session.inUse, session.userAgent)
		sessionInfo += u'</table>'
		
		diskUsageInfo  = u'<h1>Disk usage</h1>'
		diskUsageInfo += u'<table>'
		diskUsageInfo += u'<tr><th>resource</th><th>path</th><th>capacity</th><th>used</th><th>available</th><th>usage</th></tr>'
		resources = self.opsiconfd.config['staticDirectories'].keys()
		resources.sort()
		for resource in resources:
			path = self.opsiconfd.config['staticDirectories'][resource]
			if os.path.isdir(path):
				if not resource.startswith('/'): resource = u'/' + resource
				info = getDiskSpaceUsage(path)
				diskUsageInfo += u'<tr><td><a href="%s">%s</a></td><td>%s</td><td>%0.2f GB</td><td>%0.2f GB</td><td>%0.2f GB</td><td>%0.2f %%</td></tr>' \
					% (resource, resource, path, (float(info['capacity'])/1073741824), (float(info['available'])/1073741824), (float(info['used'])/1073741824), (info['usage']*100))
		diskUsageInfo += u'</table>'
		
		self.result = infoPage
		self.result = self.result.replace('%time%',            time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()))
		self.result = self.result.replace('%config_info%',     configInfo)
		self.result = self.result.replace('%thread_info%',     threadInfo)
		self.result = self.result.replace('%session_info%',    sessionInfo)
		self.result = self.result.replace('%disk_usage_info%', diskUsageInfo)
		self.result = self.result.encode('utf-8')











# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                     CLASS RESOURCE ROOT                                           =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class ResourceRoot(resource.Resource):
	addSlash = True
	def render(self, request):
		''' Process request. '''
		return http.Response(stream="<html><head><title>opsiconfd</title></head><body></body></html>")

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                     CLASS RESOURCE OPSI                                           =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class ResourceOpsi(resource.Resource):
	WorkerClass = None
	
	def __init__(self, opsiconfd):
		resource.Resource.__init__(self)
		self._opsiconfd = opsiconfd
		
	def getChild(self, name, request):
		''' Get the child resource for the requested path. '''
		if not name:
			return self
		return resource.Resource.getChild(self, name, request)
	
	def http_POST(self, request):
		''' Process POST request. '''
		try:
			logger.debug2(u"%s.http_POST()" % self.__class__.__name__)
			if not self.WorkerClass:
				raise Exception(u"No worker class defined in resource %s" % self.__class__.__name__)
			worker = self.WorkerClass(self._opsiconfd, request, self, method = 'POST')
			return worker.process()
		except Exception, e:
			logger.logException(e)
		
	def http_GET(self, request):
		''' Process GET request. '''
		try:
			logger.debug2(u"%s.http_GET()" % self.__class__.__name__)
			if not self.WorkerClass:
				raise Exception(u"No worker class defined in resource %s" % self.__class__.__name__)
			worker = self.WorkerClass(self._opsiconfd, request, self, method = 'GET')
			return worker.process()
		except Exception, e:
			logger.logException(e)
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                 CLASS RESOURCE OPSI JSONRPC                                       =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class ResourceOpsiJsonRpc(ResourceOpsi):
	WorkerClass = WorkerOpsiJsonRpc
	
	def __init__(self, opsiconfd):
		ResourceOpsi.__init__(self, opsiconfd)
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                              CLASS RESOURCE OPSI JSON INTERFACE                                   =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class ResourceOpsiJsonInterface(ResourceOpsiJsonRpc):
	WorkerClass = WorkerOpsiJsonInterface
	
	def __init__(self, opsiconfd):
		ResourceOpsiJsonRpc.__init__(self, opsiconfd)
		self._interface = self._opsiconfd.getBackend().getInterface()

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                CLASS RESOURCE OPSICONFD INFO                                      =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class ResourceOpsiconfdInfo(ResourceOpsi):
	WorkerClass = WorkerOpsiconfdInfo
	
	def __init__(self, opsiconfd):
		ResourceOpsi.__init__(self, opsiconfd)
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                   CLASS RESOURCE OPSI DAV                                         =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class ResourceOpsiDAV(static.DAVFile):
	
	def __init__(self, path, readOnly=True, defaultType="text/plain", indexNames=None):
		static.DAVFile.__init__(self, path, defaultType, indexNames)
		self._readOnly = readOnly
	
	def createSimilarFile(self, path):
		return self.__class__(path, readOnly=self._readOnly, defaultType=self.defaultType, indexNames=self.indexNames[:])
	
	def renderHTTP(self, request):
		try:
			if self._readOnly and request.method not in ('GET', 'PROPFIND'):
				logger.warning(u"Command %s not allowed (readonly)" % request.method)
				return http.Response(
					code	= responsecode.FORBIDDEN,
					stream	= "Readonly!" )
			worker = DAVWorker(request, self)
			return worker.process()
		except Exception, e:
			logger.logException(e)


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                      CLASS SSL CONTEXT                                            =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class SSLContext:
	def __init__(self, sslServerKeyFile, sslServerCertFile):
		self._sslServerKeyFile  = sslServerKeyFile
		self._sslServerCertFile = sslServerCertFile
		
	def getContext(self):
		''' Create an SSL context. '''
		
		# Test if server certificate and key file exist.
		if not os.path.isfile(self._sslServerKeyFile):
			raise Exception(u"Server key file '%s' does not exist!" % self._sslServerKeyFile)
			
		if not os.path.isfile(self._sslServerCertFile):
			raise Exception(u"Server certificate file '%s' does not exist!" % self._sslServerCertFile)
		
		context = SSL.Context(SSL.SSLv23_METHOD)
		context.use_privatekey_file(self._sslServerKeyFile)
		context.use_certificate_file(self._sslServerCertFile)
		return context

	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                         CLASS SESSION                                             =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class Session:
	def __init__(self, sessionHandler, name = u'OPSISID', sessionMaxInactiveInterval = 120):
		self.sessionHandler = sessionHandler
		self.name = forceUnicode(name)
		self.sessionMaxInactiveInterval = forceInt(sessionMaxInactiveInterval)
		self.created = time.time()
		self.lastModified = time.time()
		self.sessionTimer = None
		self.uid = Tools.randomString(32)
		self.ip = ''
		self.userAgent = ''
		self.hostname = ''
		self.user = ''
		self.password = ''
		self.authenticated = False
		self.backend = None
		self.interface = None
		self.inUse = False
		self.touch()
	
	def setInUse(self, inUse):
		self.inUse = forceBool(inUse)
		self.touch()
		
	def touch(self):
		self.lastModified = time.time()
		if self.sessionTimer:
			self.sessionTimer.cancel()
			self.sessionTimer.join(1)
		self.sessionTimer = threading.Timer(self.sessionMaxInactiveInterval, self.expire)
		self.sessionTimer.start()
	
	def expire(self):
		self.sessionHandler.sessionExpired(self)
	
	def delete(self):
		if self.inUse:
			logger.warning(u"Deleting session in use: %s" % self)
		if self.sessionTimer:
			try:
				self.sessionTimer.cancel()
				try:
					self.sessionTimer.join(1)
				except:
					pass
				logger.info(u"Session timer %s canceled" % self.sessionTimer)
			except Exception, e:
				logger.error(u"Failed to cancel session timer: %s" % e)
		if session.backend:
			logger.debug(u"Calling exit() on backend %s" % session.backend)
			session.backend.exit()
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                    CLASS SESSION HANDLER                                          =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class SessionHandler:
	def __init__(self, sessionName = 'OSPISID', sessionMaxInactiveInterval = 120):
		self.sessionName = sessionName
		self.sessionMaxInactiveInterval = sessionMaxInactiveInterval
		self.sessions = {}
	
	def stop(self):
		self.deleteAllSessions()
	
	def getSessions(self):
		return self.sessions
		
	def getSession(self, uid):
		if uid:
			session = self.sessions.get(uid)
			if session:
				return session
			else:
				logger.info(u'Failed to get session: session id %s not found' % uid)
		return self.createSession()
	
	def createSession(self):
		session = Session(self, self.sessionName, self.sessionMaxInactiveInterval)
		self.sessions[session.uid] = session
		logger.notice(u"New session created")
		return session
	
	def sessionExpired(self, session):
		logger.notice(u"Session '%s' from ip '%s', application '%s' expired after %d seconds" \
				% (session.uid, session.ip, session.userAgent, (time.time()-session.lastModified)))
		if session.inUse:
			logger.notice(u"Session currently in use, waiting before deletion")
		while session.inUse:
			time.sleep(1)
		self.deleteSession(session.uid)
		
	def deleteSession(self, uid):
		session = self.sessions.get(uid)
		if not session:
			logger.warning(u'No such session id: %s' % uid)
			return
		
		try:
			session.delete()
		except:
			pass
		
		try:
			del self.sessions[uid]
			logger.notice(u"Session '%s' from ip '%s', application '%s' deleted" % (session.uid, session.ip, session.userAgent))
			del session
		except KeyError:
			pass
	
	def deleteAllSessions(self):
		logger.notice(u"Deleting all sessions")
		for (uid, session) in self.sessions.items():
			logger.notice(u"Deleting session '%s'" % uid)
			self.deleteSession(uid)
		self.sessions = {}
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                       CLASS OPSICONFD                                             =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class Opsiconfd(threading.Thread):
	def __init__(self, config):
		threading.Thread.__init__(self)
		
		self.config          = config
		self._running        = False
		
		self._backend        = None
		self._root           = None
		self._site           = None
		self._httpServer     = None
		self._httpsServer    = None
		self._sessionHandler = None
		
		self.setLogging()
		logger.comment(	"\n==================================================================\n" \
				+ "=             OPSI configuration-service starting                =\n" \
				+ "==================================================================\n")
	
	def isRunning(self):
		return self._running
	
	def getBackend(self):
		return self._backend
	
	def getSessionHandler(self):
		return self._sessionHandler
	
	def stop(self):
		logger.notice(u"Stopping opsiconfd main thread")
		if self._httpServer:
			self._httpServer.stopListening()
			self._httpServer = None
			logger.notice(u"No longer accepting http requests")
		if self._httpsServer:
			self._httpsServer.stopListening()
			self._httpsServer = None
			logger.notice(u"No longer accepting https requests")
		
		if self._sessionHandler:
			logger.notice(u"Stopping session handler")
			self._sessionHandler.stop()
		
		if reactor.running:
			try:
				logger.notice(u"Stopping reactor")
				reactor.stop()
			except Exception, e:
				logger.error(u"Failed to stop reactor: %s" % e)
		self._running = False
		
	def setLogging(self):
		# Set logging options
		self.config['machineLogs'] = False
		if self.config['logFile']:
			if (self.config['logFile'].find('%m') != -1):
				self.config['machineLogs'] = True
			logger.setLogFile( self.config['logFile'].replace('%m', 'opsiconfd') )
		
		if self.config['logFormat']:
			logger.setLogFormat(self.config['logFormat'])
		logger.setFileLevel(self.config['logLevel'])
		
		def twistedLogObserver(eventDict):
			if eventDict.get('isError'):
				if eventDict.get('failure'):
					logger.logTraceback(eventDict['failure'].getTracebackObject())
					logger.critical(u"     ==>>> %s" % eventDict['failure'].getErrorMessage())
				for line in eventDict.get('message', ()):
					logger.error(line)
			else:
				for line in eventDict.get('message', ()):
					logger.debug(u"[twisted] %s" % line)
		
		log.startLoggingWithObserver(twistedLogObserver, setStdout=0)
	
	def createBackendInstance(self):
		logger.info(u"Creating backend instance")
		self._backend = BackendManager(
			dispatchConfigFile = self.config['dispatchConfigFile'],
			backendConfigDir   = self.config['backendConfigDir'],
			extensionConfigDir = self.config['extensionConfigDir'],
			#aclFile            = self.config['aclFile']
		)
	
	def createSite(self):
		logger.info(u"Creating site")
		if self.config['staticDirectories'].get('/'):
			if not os.path.isdir(self.config['staticDirectories']['/']):
				logger.error(u"Cannot add static content '/': directory '%s' does not exist." \
					% staticDirectories.get('/'))
			else:
				self._root = static.File(self.config['staticDirectories']['/'])
				logger.notice(u"Added static content '/' which points to directory '%s'" \
					% self.config['staticDirectories']['/'])
		
		if not self._root:
			self._root = ResourceRoot()
		
		self._root.putChild('rpc',       ResourceOpsiJsonRpc(self))
		self._root.putChild('interface', ResourceOpsiJsonInterface(self))
		self._root.putChild('info',      ResourceOpsiconfdInfo(self))
		
		for (name, path) in self.config['staticDirectories'].items():
			if (name == '/'):
				continue
			
			if name in ('rpc', 'interface', 'info'):
				logger.error(u"Cannot add static content '%s', already in use!" % name)
				continue
			
			if not os.path.isdir(path):
				logger.error(u"Cannot add static content '%s': directory '%s' does not exist." % (name, path))
				continue
			
			if (name == 'configed'):
				self._root.putChild(name, static.File(path))
				logger.notice(u"Added static content '%s' which points to directory '%s'" % (name, path))
				continue
			
			self._root.putChild(name, ResourceOpsiDAV(path, readOnly=True))
			logger.notice(u"Added webdav content '%s' which points to directory '%s'" % (name, path))
		
		hosts = self._backend.host_getObjects(type = 'OpsiDepotserver', id = self.config['depotId'])
		if hosts:
			depot = hosts[0]
			logger.notice(u"Running on depot server '%s', exporting depot directory" % self.config['depotId'])
			if not depot.getRepositoryLocalUrl():
				raise Exception(u"Repository local url for depot '%s' not found" % self.config['depotId'])
			if not depot.getRepositoryLocalUrl().startswith('file:///'):
				raise Exception(u"Repository local url '%s' not allowed" % depot.getRepositoryLocalUrl())
			path = depot.getRepositoryLocalUrl()[7:]
			if not os.path.isdir(path):
				raise Exception(u"Cannot add webdav content 'products': directory '%s' does not exist." % path)
			if not os.access(path, os.R_OK | os.W_OK | os.X_OK):
				raise Exception(u"Cannot add webdav content 'products': permissions on directory '%s' not sufficient." % path)
			
			self._root.putChild('products', ResourceOpsiDAV(path, readOnly=False))
			logger.notice(u"Added static content 'products' which points to directory '%s'" % path)
		
		self._site = server.Site(self._root)
	
	def startListening(self):
		if (self.config['httpPort'] > 0):
			if (self.config['interface'] == '0.0.0.0'):
				self._httpServer = reactor.listenTCP(
					self.config['httpPort'],
					HTTPFactory(self._site)
				)
			else:
				self._httpServer = reactor.listenTCP(
					self.config['httpPort'],
					HTTPFactory(self._site),
					interface = self.config['interface']
				)
			
			logger.notice(u"Accepting HTTP requests on %s:%s" % (self.config['interface'], self.config['httpPort']))
		
		if (self.config['httpsPort'] > 0):
			if (self.config['interface'] == '0.0.0.0'):
				self._httpsServer = reactor.listenSSL(
					self.config['httpsPort'],
					HTTPFactory(self._site),
					SSLContext(self.config['sslServerKeyFile'], self.config['sslServerCertFile'])
				)
			else:
				self._httpsServer = reactor.listenSSL(
					self.config['httpsPort'],
					HTTPFactory(self._site),
					SSLContext(self.config['sslServerKeyFile'], self.config['sslServerCertFile']),
					interface = self.config['interface']
				)
			
			logger.notice(u"Accepting HTTPS requests on %s:%s" % (self.config['interface'], self.config['httpsPort']))
		
	def run(self):
		self._running = True
		logger.notice(u"Starting opsiconfd main thread")
		try:
			self.createBackendInstance()
			self._sessionHandler = SessionHandler(
				sessionName                = self.config['sessionName'],
				sessionMaxInactiveInterval = self.config['sessionMaxInactiveInterval']
			)
			self.createSite()
			self.startListening()
			if not reactor.running:
				reactor.run(installSignalHandlers=0)
			
			logger.notice(u"Opsiconfd main thread exiting...")
		except Exception, e:
			logger.logException(e)
		self._running = False
	
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# -                                           OPSICONFD INIT                                          -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class OpsiconfdInit(object):
	def __init__(self):
		logger.debug(u"OpsiconfdInit")
		# Set umask
		os.umask(0077)
		
		self._pid = 0
		self.config = {
			'pidFile'                      : u'/var/run/opsiconfd/opsiconfd.pid',
			'configFile'                   : u'/etc/opsi/opsiconfd.conf',
			'daemon'                       : False,
			'logLevel'                     : LOG_NOTICE,
			'logFile'                      : u'/var/log/opsi/opsiconfd/opsiconfd.log',
			'logFormat'                    : u'[%l] [%D] %M (%F|%N)',
			'symlinkLogs'                  : False,
			'httpPort'                     : 0,
			'httpsPort'                    : 4447,
			'interface'                    : u'0.0.0.0',
			'backendManagerConf'           : None,
			'maxExecutionStatisticValues'  : 250,
			'sslServerCertFile'            : u'/etc/opsi/opsiconfd.pem',
			'sslServerKeyFile'             : u'/etc/opsi/opsiconfd.pem',
			'sessionName'                  : u'OPSISID',
			'resolveClientIp'              : True,
			'resolveVerifyIp'              : False,
			'sessionMaxInactiveInterval'   : 120,
			'updateHardwareAddress'        : True,
			'staticDirectories'            : {},
			'depotId'                      : socket.getfqdn(),
			'backendConfigDir'             : '/etc/opsi/backends',
			'dispatchConfigFile'           : '/etc/opsi/backendManager/dispatch.conf',
			'extensionConfigDir'           : '/etc/opsi/backendManager/compose.d',
			'aclFile '                     : '/etc/opsi/backendManager/acl.conf'
		}
		
		argv = sys.argv[1:]
		
		# Call signalHandler on signal SIGHUP, SIGTERM, SIGINT
		signal(SIGHUP,  self.signalHandler)
		signal(SIGTERM, self.signalHandler)
		signal(SIGINT,  self.signalHandler)
		
		# Process command line arguments
		try:
			(opts, args) = getopt.getopt(argv, "vc:f:l:p:P:i:D")
		
		except getopt.GetoptError:
			self.usage()
			sys.exit(1)
		
		for (opt, arg) in opts:
			if (opt == "-c"):
				self.config['configFile'] = forceFilename(arg)
		
		self.readConfigFile()
		
		for (opt, arg) in opts:
			if   (opt == "-v"):
				print u"opsiconfd version %s" % __version__
				sys.exit(0)
			if   (opt == "-D"):
				self.config['daemon'] = True
			elif (opt == "-l"):
				self.config['logLevel'] = forceInt(arg)
			elif (opt == "-f"):
				self.config['logFile'] = forceFilename(arg)
			elif (opt == "-p"):
				self.config['httpPort'] = forceInt(arg)
			elif (opt == "-P"):
				self.config['httpsPort'] = forceInt(arg)
			elif (opt == "-i"):
				self.config['interface'] = forceUnicode(arg)
		
		if self.config['daemon']:
			logger.setConsoleLevel(LOG_NONE)
			self.daemonize()
		else:
			logger.setConsoleLevel(self.config['logLevel'])
			logger.setConsoleColor(True)
		
		self.createPidFile()
		
		# Start opsiconfd
		self._opsiconfd = Opsiconfd(self.config)
		self._opsiconfd.start()
		while self._opsiconfd.isRunning():
			time.sleep(1)
		self._opsiconfd.join(1)
		self.removePidFile()
		
		
	def createPidFile(self):
		logger.info(u"Creating pid file '%s'" % self.config['pidFile'])
		if os.path.exists(self.config['pidFile']):
			pf = open(self.config['pidFile'], 'r')
			p = pf.readline().strip()
			pf.close()
			if p:
				running = False
				try:
					for i in execute("%s -x opsiconfd" % which("pidof"))[0].strip().split():
						if (i == p):
							running = True
							break
				except Exception, e:
					logger.error(e)
				if running:
					raise Exception(u"Another opsiconfd process is running (pid: %s), stop process first or change pidfile." % p )
				
		pid = os.getpid()
		pf = open (self.config['pidFile'], "w")
		print >> pf, str(pid)
		pf.close()
	
	def removePidFile(self):
		try:
			# if (self._pid == os.getpid())
			if os.path.exists(self.config['pidFile']):
				logger.info(u"Removing pid file '%s'" % self.config['pidFile'])
				os.unlink(self.config['pidFile'])
		except Exception, e:
			logger.error(u"Failed to remove pid file '%s': %s" % (self.config['pidFile'], e))
		
	def signalHandler(self, signo, stackFrame):
		for thread in threading.enumerate():
			logger.info(u"Running thread before signal: %s" % thread)
		
		if (signo == SIGHUP):
			return
		if (signo == SIGTERM or signo == SIGINT):
			if self._opsiconfd:
				self._opsiconfd.stop()
		
		for thread in threading.enumerate():
			logger.info(u"Running thread after signal: %s" % thread)
		
	def readConfigFile(self):
		''' Get settings from config file '''
		logger.notice(u"Trying to read config from file: '%s'" % self.config['configFile'])
		
		try:
			iniFile = IniFile(filename = self.config['configFile'], raw = True)
			config = iniFile.parse()
			
			for section in config.sections():
				logger.debug(u"Processing section '%s' in config file: '%s'" % (section, self.config['configFile']))
				if (section.lower() == 'global'):
					# Global settings
					for (option, value) in config.items(section):
						if   (option == 'bm config'):
							self.config['backendManagerConf'] = forceFilename(value)
						elif (option == 'pid file'):
							self.config['pidFile'] = forceFilename(value)
						elif (option == 'log level'):
							self.config['logLevel'] = forceInt(value)
						elif (option == 'log file'):
							self.config['logFile'] = forceFilename(value)
						elif (option == 'log format'):
							self.config['logFormat'] = forceUnicode(value)
						elif (option == 'symlink logs'):
							self.config['symlinkLogs'] = forceBool(value)
						elif (option == 'max execution statistics'):
							self.config['maxExecutionStatisticValues'] = forceInt(value)
						else:
							logger.warning(u"Ignoring unknown option '%s' in config file: '%s'" % (option, self.config['configFile']))
				
				elif (section.lower() == 'service'):
					# Service settings
					for (option, value) in config.items(section):
						if   (option == 'http port'):
							self.config['httpPort'] = forceInt(value)
						elif (option == 'https port'):
							self.config['httpsPort'] = forceInt(value)
						elif (option == 'interface'):
							self.config['interface'] = forceUnicode(value)
						elif (option == 'ssl server cert'):
							self.config['sslServerCertFile'] = forceFilename(value)
						elif (option == 'ssl server key'):
							self.config['sslServerKeyFile'] = forceFilename(value)
						else:
							logger.warning(u"Ignoring unknown option '%s' in config file: '%s'" % (option, self.config['configFile']))
				
				elif (section.lower() == 'session'):
					# Session settings
					for (option, value) in config.items(section):
						if   (option == 'session name'):
							self.config['sessionName'] = forceUnicode(value)
						elif (option == 'resolve ip'):
							self.config['resolveClientIp'] = forceBool(value)
						elif (option == 'verify ip'):
							self.config['resolveVerifyIp'] = forceBool(value)
						elif (option == 'max inactive interval'):
							self.config['sessionMaxInactiveInterval'] = forceInt(value)
						elif (option == 'update hardware address'):
							self.config['updateHardwareAddress'] = forceBool(value)
						else:
							logger.warning(u"Ignoring unknown option '%s' in config file: '%s'" % (option, self.config['configFile']))
				
				elif (section.lower() == 'directories'):
					# Static directories
					self.config['staticDirectories'] = {}
					for (option, value) in config.items(section):
						self.config['staticDirectories'][option] = forceFilename(value)
				else:
					logger.warning(u"Ignoring unknown section '%s' in config file: '%s'" % (section, self.config['configFile']))
		
		except Exception, e:
			# An error occured while trying to read the config file
			logger.error(u"Failed to read config file '%s': %s" % (self.config['configFile'], e))
			logger.logException(e)
			raise
		logger.notice(u"Config read")
		
	def usage(self):
		print u"\nUsage: %s [-D] [-c <filename>] [-f <filename>] [-l <log level>] [-i <ipaddress>] [-p <http port>] [-P <https port>]" % os.path.basename(sys.argv[0])
		print u"Options:"
		print u"  -v    Show version information and exit"
		print u"  -D    Causes the server to operate as a daemon"
		print u"  -p    HTTP Port to listen on (0 to disable)"
		print u"  -P    HTTPS Port to listen on (0 to disable)"
		print u"  -i    IP address of interface to listen on (default: 0.0.0.0)"
		print u"  -f    Log to given file instead of syslog"
		print u"  -c    Location of config file"
		print u"  -l    Set log level (default: 4)"
		print u"        0=nothing, 1=critical, 2=error, 3=warning, 4=notice, 5=info, 6=debug, 7=debug2, 9=confidential"
		print u""
	
	def daemonize(self):
		# Fork to allow the shell to return and to call setsid
		try:
			self._pid = os.fork()
			if (self._pid > 0):
				# Parent exits
				sys.exit(0)
		except OSError, e:
			raise Exception(u"First fork failed: %e" % e)
		
		# Do not hinder umounts
		os.chdir("/")
		# Create a new session
		os.setsid()
		
		# Fork a second time to not remain session leader
		try:
			self._pid = os.fork()
			if (self._pid > 0):
				sys.exit(0)
		except OSError, e:
			raise Exception(u"Second fork failed: %e" % e)
		
		logger.setConsoleLevel(LOG_NONE)
		
		# Close standard output and standard error.
		os.close(0)
		os.close(1)
		os.close(2)
		
		# Open standard input (0)
		if (hasattr(os, "devnull")):
			os.open(os.devnull, os.O_RDWR)
		else:
			os.open("/dev/null", os.O_RDWR)
		
		# Duplicate standard input to standard output and standard error.
		os.dup2(0, 1)
		os.dup2(0, 2)
		sys.stdout = logger.getStdout()
		sys.stderr = logger.getStderr()

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# -                                               MAIN                                                -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if (__name__ == "__main__"):
	logger.setConsoleLevel(LOG_WARNING)
	exception = None
	
	try:
		OpsiconfdInit()
		
	except SystemExit, e:
		pass
		
	except Exception, e:
		exception = e
	
	if exception:
		logger.logException(exception)
		print >> sys.stderr, u"ERROR:", unicode(exception)
		sys.exit(1)
	sys.exit(0)



