#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
   = = = = = = = = = = = = = = = = = = = = = = =
   =   opsi configuration daemon (opsiconfd)   =
   = = = = = = = = = = = = = = = = = = = = = = =
   
   opsiconfd is part of the desktop management solution opsi
   (open pc server integration) http://www.opsi.org
   
   Copyright (C) 2008 uib GmbH
   
   http://www.uib.de/
   
   All rights reserved.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License version 2 as
   published by the Free Software Foundation.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   
   @copyright:	uib GmbH <info@uib.de>
   @author: Jan Schneider <j.schneider@uib.de>
   @license: GNU General Public License version 2
"""

__version__ = '3.4.99'

# Imports
import os, sys, getopt, threading, time, socket, base64, urllib, json, operator
from OpenSSL import SSL
from signal import *

# Twisted imports
from twisted.internet import defer, threads, reactor
from twisted.python.failure import Failure
from twisted.python import log
from OPSI.web2 import resource, stream, server, http, responsecode
from OPSI.web2 import http_headers
from OPSI.web2.channel.http import HTTPFactory
from OPSI.web2.dav import static

# OPSI imports
from OPSI.Logger import *
from OPSI.Util.File import IniFile
from OPSI.Types import *
from OPSI.System import which, execute, getDiskSpaceUsage
from OPSI.Backend.BackendManager import BackendManager
from OPSI import Tools
from OPSI.Object import serialize, deserialize

logger = Logger()
logger.setConsoleLevel(100)


infoPage = u'''
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>opsiconfd info</title>
	<style>
	a:link 	  { color: #555555; text-decoration: none; }
	a:visited { color: #555555; text-decoration: none; }
	a:hover	  { color: #46547f; text-decoration: none; }
	a:active  { color: #555555; text-decoration: none; }
	body      { font-family: verdana, arial; font-size: 12px; }
	#title    { padding: 10px; color: #6276a0; font-size: 20px; letter-spacing: 5px; }
	#infos    { padding: 50px; color: #555555; font-size: 14px; }
	#info     { padding-bottom: 20px }
	h1        { font-size: 14px; font-weight; bold; letter-spacing: 2px; }
	table     { table-layout: auto; background-color: #fafafa; }
	td, th    { font-size: 12px; border: 1px #6276a0 solid; text-align: left; padding: 2px 10px 2px 10px; }
	th        { color: #eeeeee; background-color: #6276a0; }
	</style>
</head>
<body>
	<span id="title">
		<img src="opsi_logo.png" />
		<span sytle="padding: 1px">opsiconfd info</span>
	</span>
	<div id="infos">
		<div id="info">%time%</div>
		<div id="info">%config_info%</div>
		<div id="info">%thread_info%</div>
		<div id="info">%session_info%</div>
		<div id="info">%disk_usage_info%</div>
		<div id="info">%rpc_statistic_info%</div>
	</div>
</body>
'''

interfacePage = u'''
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>opsi config interface</title>
	<style>
	a:link 	      { color: #555555; text-decoration: none; }
	a:visited     { color: #555555; text-decoration: none; }
	a:hover	      { color: #46547f; text-decoration: none; }
	a:active      { color: #555555; text-decoration: none; }
	body          { font-family: verdana, arial; font-size: 12px; }
	#title        { padding: 10px; color: #6276a0; font-size: 20px; letter-spacing: 5px; }
	input, select { background-color: #fafafa; border: 1px #abb1ef solid; width: 430px; font-family: verdana, arial; }
	.json         { color: #555555; width: 600px; float: left; clear: both; margin: 30px; padding: 20px; background-color: #fafafa; border: 1px #abb1ef dashed; font-size: 11px; }
	.json_key     { color: #9e445a; }
	.json_label   { color: #abb1ef; margin-top: 20px; margin-bottom: 5px; font-size: 11px; }
	.title        { color: #555555; font-size: 20px; font-weight: bolder; letter-spacing: 5px; }
	.button       { color: #9e445a; background-color: #fafafa; border: none; margin-top: 20px; font-weight: bolder; }
	.box          { background-color: #fafafa; border: 1px #555555 solid; padding: 20px; margin-left: 30px; margin-top: 50px;}
	</style>
	<script type="text/javascript">
		var parameters = new Array();
		var method = '';
		var params = '';
		var id = '"id": 1';
		%javascript%
		function selectFunction(select) {
			method = select.value;
			tbody = document.getElementById('tbody');
			var button;
			var json;
			for (i=tbody.childNodes.length-1; i>=0; i--) {
				if (tbody.childNodes[i].id == 'tr_method') {
				}
				else if (tbody.childNodes[i].id == 'tr_submit') {
					button = tbody.childNodes[i];
					tbody.removeChild(button);
				}
				else if (tbody.childNodes[i].id == 'tr_json') {
					json = tbody.childNodes[i];
					tbody.removeChild(json);
				}
				else {
					tbody.removeChild(tbody.childNodes[i]);
				}
			}

			for (i=0; i < parameters[select.value].length; i++) {
				tr = document.createElement("tr");
				td1 = document.createElement("td");
				text = document.createTextNode(parameters[select.value][i] + ":");
				td1.appendChild(text);
				td2 = document.createElement("td");
				input = document.createElement("input");
				input.setAttribute('onchange', 'jsonString()');
				input.setAttribute('type', 'text');
				if ((method == currentMethod) && (currentParams[i] != null)) {
					input.value = currentParams[i];
				}
				td2.appendChild(input);
				tr.appendChild(td1);
				tr.appendChild(td2);
				tbody.appendChild(tr)
			}
			tbody.appendChild(json)
			tbody.appendChild(button)
			
			jsonString();
		}
		
		function onSubmit() {
			var json = '{ "id": 1, "method": ';
			json += document.getElementById('json_method').firstChild.data;
			json += ', "params": ';
			json += document.getElementById('json_params').firstChild.data;
			json += ' }';
			window.location.href = '?' + json;
			return false;
		}
		
		function jsonString() {
			span = document.getElementById('json_method');
			for (i=span.childNodes.length-1; i>=0; i--) {
				span.removeChild(span.childNodes[i])
			}
			span.appendChild(document.createTextNode('"' + method + '"'));
			
			span = document.getElementById('json_params');
			for (i=span.childNodes.length-1; i>=0; i--) {
				span.removeChild(span.childNodes[i])
			}
			params = '['
			inputs = document.getElementsByTagName('input');
			for (i=0; i<inputs.length; i++) {
				if (inputs[i].id != 'submit') {
					if (inputs[i].value == '') {
						i = inputs.length;
					}
					else {
						if (i>0) {
							params += ', ';
						}
						params += inputs[i].value.replace(/\\\/g, '\\\\\\\\');
					}
				}
			}
			span.appendChild(document.createTextNode(params + ']'));
		}
	</script>
</head>
<body onload="selectFunction(document.getElementById('select'))">
	<span id="title">
		<img src="opsi_logo.png" />
		<span sytle="padding: 1px">opsi config interface</span>
	</span>
	<form action="cgi" method="post" onsubmit="return onSubmit()">
		<table class="box">
			<tbody id="tbody">
				<tr id="tr_method">
					<td style="width: 150px;">Method:</td>
					<td style="width: 440px;">
						<select id="select" onchange="selectFunction(this)" name="method">
							%select_method%
						</select>
					</td>
				</tr>
				<tr id="tr_json">
					<td colspan="2">
						<div class="json_label">
							resulting json remote procedure call:
						</div>
						<div class="json" style="width: 480px;">
							{&nbsp;"<font class="json_key">method</font>": <span id="json_method"></span>,<br />
							&nbsp;&nbsp;&nbsp;"<font class="json_key">params</font>": <span id="json_params">[]</span>,<br />
							&nbsp;&nbsp;&nbsp;"<font class="json_key">id</font>": 1 }
						</div>
					</td>
				</tr>
				<tr id="tr_submit">
					<td align="center" colspan="2">
						<input value="Execute" id="submit" class="button" type="submit" />
					</td>
				</tr>
			</tbody>
		</table>
	</form>
	<div class="json_label" style="padding-left: 30px">json-rpc result</div>
	%result%
</body>
'''

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                  OPSICONFD ERROR CLASSES                                          =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class OpsiconfdError(Exception):
	ExceptionShortDescription = u"Opsiconfd error"
	
	def __init__(self, message = u''):
		self._message = forceUnicode(message)
	
	def __unicode__(self):
		if self._message:
			return u"%s: %s" % (self.ExceptionShortDescription, self._message)
		else:
			return u"%s" % self.ExceptionShortDescription
		
	def __repr__(self):
		return unicode(self).encode("utf-8")
	
	__str__ = __repr__

class OpsiconfdAuthenticationError(Exception):
	ExceptionShortDescription = u"Opsiconfd authentication error"

class OpsiconfdBadRpcError(Exception):
	ExceptionShortDescription = u"Opsiconfd bad rpc error"

class OpsiconfdRpcError(Exception):
	ExceptionShortDescription = u"Opsiconfd rpc error"

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                        CLASS WORKER                                               =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class Worker:
	def __init__(self, opsiconfd, request, resource):
		self.opsiconfd = opsiconfd
		self.request   = request
		self.query     = u''
		self.resource  = resource
		self.session   = None
		self._setLogFile()
	
	def process(self):
		logger.info("Worker %s started processing" % self)
		deferred = defer.Deferred()
		deferred.addCallback(self._getSession)
		deferred.addCallback(self._linkLogFile)
		deferred.addCallback(self._authenticate)
		deferred.addCallback(self._getQuery)
		deferred.addCallback(self._decodeQuery)
		deferred.addCallback(self._setResponse)
		deferred.addCallback(self._setCookie)
		deferred.addCallback(self._freeSession)
		deferred.addErrback(self._errback)
		deferred.callback(None)
		return deferred
	
	def _errback(self, failure):
		logger.debug2("%s._errback" % self.__class__.__name__)
		
		self._freeSession(failure)
		
		result = self._renderError(failure)
		result.code = responsecode.INTERNAL_SERVER_ERROR
		try:
			failure.raiseException()
		except OpsiconfdAuthenticationError, e:
			logger.error(e)
			result.code = responsecode.UNAUTHORIZED
			result.headers.setHeader('www-authenticate', [('basic', { 'realm': 'OPSI Configuration Service' } )])
		except OpsiconfdBadRpcError, e:
			logger.error(e)
			result.code = responsecode.BAD_REQUEST
		except Exception, e:
			logger.logException(e)
		
		return result
	
	def _renderError(self, failure):
		result = http.Response()
		result.headers.setHeader('content-type', http_headers.MimeType("text", "html", {"charset": "utf-8"}))
		error = u'Unknown error'
		try:
			failure.raiseException()
		except Exception, e:
			error = unicode(e)
		result.stream = stream.IByteStream(error.encode('utf-8'))
		return result
		
	def _setLogFile(self):
		if self.opsiconfd.config['machineLogs'] and self.opsiconfd.config['logFile']:
			logger.setLogFile( self.opsiconfd.config['logFile'].replace('%m', self.request.remoteAddr.host), object = self )
	
	def _linkLogFile(self, result):
		if self.session.hostname and self.opsiconfd.config['machineLogs'] and self.opsiconfd.config['logFile']:
			logger.linkLogFile( self.opsiconfd.config['logFile'].replace('%m', self.session.hostname), object = self )
		return result
		
	def _freeSession(self, result):
		if self.session:
			logger.debug(u"Freeing session %s" % self.session)
			self.session.decreaseUsageCount()
		return result
	
	def _getSession(self, result):
		''' This method restores a session or generates a new one. '''
		self.session = None
		
		logger.confidential(u"Request headers: %s " % self.request.headers)
		
		# Get user agent
		userAgent = None
		try:
			userAgent = self.request.headers.getHeader('user-agent')
		except Exception, e:
			logger.info(u"Client '%s' did not supply user-agent" % self.request.remoteAddr.host)
		if not userAgent:
			userAgent = 'unknown'
		
		# Get session handler
		sessionHandler = self.opsiconfd.getSessionHandler()
		
		# Get session id from cookie request header
		sessionId = u''
		try:
			for cookie in self.request.headers.getHeader('cookie'):
				if (cookie.name == sessionHandler.sessionName):
					sessionId = unicode(cookie.value)
		except Exception, e:
			pass
		
		if not sessionId:
			logger.notice(u"Application '%s' on client '%s' did not send cookie" % (userAgent, self.request.remoteAddr.host))
		
		# Get Session object
		self.session = sessionHandler.getSession(sessionId)
		if (sessionId == self.session.uid):
			logger.info(u"Reusing session for client '%s', application '%s'" % (self.request.remoteAddr.host, userAgent))
		elif sessionId:
			logger.notice(u"Application '%s' on client '%s' supplied non existing session id: %s" % (userAgent, self.request.remoteAddr.host, sessionId))
		
		if self.session.ip and (self.session.ip != self.request.remoteAddr.host):
			logger.critical(u"Client ip '%s' does not match session ip '%s', deleting old session and creating a new one" \
				% (self.request.remoteAddr.host, self.session.ip) )
			sessionHandler.deleteSession(self.session.uid)
			self.session = sessionHandler.getSession()
		
		# Set ip
		self.session.ip = self.request.remoteAddr.host
		
		# Set user-agent / application
		if self.session.userAgent and (self.session.userAgent != userAgent):
			logger.warning(u"Application changed from '%s' to '%s' for existing session of client '%s'" \
				% (self.session.userAgent, userAgent, self.request.remoteAddr.host))
		self.session.userAgent = userAgent
		
		logger.confidential(u"Session id is '%s' for client '%s', application '%s'" \
			% (self.session.uid, self.request.remoteAddr.host, self.session.userAgent))
		
		# Set last modified to current time
		self.session.increaseUsageCount()
		
		# Set user and password
		if not self.session.user and not self.session.password and self.request.headers.getHeader('Authorization'):
			(user, password) = ('', '')
			logger.debug(u"Trying to get username and password from Authorization header")
			auth = self.request.headers.getHeader('Authorization')
			if auth:
				logger.debug(u"Authorization header found (type: %s)" % auth[0])
				try:
					encoded = auth[1]
					(user, password) = base64.decodestring(encoded).split(':', 1)
					logger.confidential(u"Client supplied username '%s' and password '%s'" % (user, password))
				except Exception, e:
					raise Exception(u"Bad Authorization header from '%s': %s" % (self.request.remoteAddr.host, e))
			
			self.session.user = user
			self.session.password = password
			if (self.session.user.count('.') >= 2):
				self.session.isHost = True
			
		# Set hostname
		if not self.session.hostname:
			hostname = ''
			if self.session.isHost:
				hostname = self.session.user
			elif self.opsiconfd.config['resolveClientIp']:
				try:
					hostname = socket.getfqdn(self.request.remoteAddr.host).lower()
					if re.search('^\d+\.\d+\.\d+\.\d+$', hostname):
						logger.error(u"Cannot get fqdn for client '%s'" % self.request.remoteAddr.host)
						hostname = ''
					elif (hostname.count('.') == 1):
						logger.error(u"Cannot get fqdn for client '%s', got hostname '%s' only" % (self.request.remoteAddr.host, hostname))
						hostname = ''
				except Exception, e:
					logger.warning(u"Failed to resolve address '%s': %s" % (self.request.remoteAddr.host, e))
			if hostname:
				logger.info(u"Storing hostname '%s' in session" % hostname)
				self.session.hostname = hostname
			else:
				logger.debug(u"Failed to get hostname for client '%s'" % self.request.remoteAddr.host)
		
		logger.confidential(u"Session content: %s" % self.session.__dict__)
		return result
	
	def _setCookie(self, result):
		# Add cookie to headers
		cookie = http_headers.Cookie(self.session.name.encode('ascii', 'replace'), self.session.uid.encode('ascii', 'replace'), path='/')
		if not isinstance(result, http.Response):
			result = http.Response()
		result.headers.setHeader('set-cookie', [ cookie ] )
		return result
		
	def _authenticate(self, result):
		''' This function tries to authenticate a user.
		    Raises an exception on authentication failure. '''
		
		try:
			if self.session.authenticated:
				return result
			
			logger.notice(u"Authorization request from %s@%s" % (self.session.user, self.session.ip))
			if not self.session.user:
				raise Exception(u"Cannot authenticate, no username given")
			
			if self.session.hostname and self.opsiconfd.config['resolveVerifyIp'] and (self.session.user != self.opsiconfd.config['fqdn']):
				addressList = []
				try:
					(name, aliasList, addressList) = socket.gethostbyname_ex(self.session.hostname)
				except Exception, e:
					logger.warning(u"Failed to resolve hostname '%s': %s" % (self.session.hostname, e))
				
				if self.session.ip not in addressList:
					# Username (FQDN) of peer does not resolve to peer's ip address
					logger.critical(u"Host login attempt with username '%s'" % self.session.user +
							u" from ip '%s', but name resolves to '%s' (access denied)" % 
							( self.session.ip, addressList) )
					raise Exception(u"Access denied for username '%s' from '%s'" %
							(self.session.user, self.session.ip) )
			
			self._createBackend()
			
			self.session.authenticated = True
			
		except Exception, e:
			self._freeSession(result)
			self.opsiconfd.getSessionHandler().deleteSession(self.session.uid)
			raise OpsiconfdAuthenticationError(u"Forbidden: %s" % e)
		return result
	
	def _getQuery(self, result):
		self.query = ''
		if   (self.request.method == 'GET'):
			self.query = urllib.unquote( self.request.querystring )
		elif (self.request.method == 'POST'):
			# Returning deferred needed for chaining
			d = stream.readStream(self.request.stream, self._handlePostData)
			d.addErrback(self._errback)
			return d
		else:
			raise ValueError(u"Unhandled method %s" % request.method)
		return result
		
	def _handlePostData(self, chunk):
		logger.debug2(u"_handlePostData %s" % chunk)
		self.query += chunk
	
	def _decodeQuery(self, result):
		self.query = unicode(self.query, 'utf-8', 'replace')
		logger.debug2(u"query: %s" % self.query)
		return result
	
	def _createBackend(self):
		if self.session.backend and self.session.interface:
			return result
		
		self.session.backend = BackendManager(
			dispatchConfigFile = self.opsiconfd.config['dispatchConfigFile'],
			backendConfigDir   = self.opsiconfd.config['backendConfigDir'],
			extensionConfigDir = self.opsiconfd.config['extensionConfigDir'],
			#aclFile            = self.opsiconfd.config['aclFile'],
			depotBackend       = bool(self.opsiconfd.config['depotId'])
		)
		logger.notice(u'Backend created: %s' % self.session.backend)
		self.session.interface = self.session.backend.getInterface()
		if self.session.isHost:
			hosts = self.session.backend.host_getObjects(id = self.session.user)
			if not hosts:
				raise Exception(u"Host '%s' not found in backend" % self.session.user)
			host = hosts[0]
			if (host.getType() == 'OpsiClient'):
				host.setLastSeen(Tools.timestamp())
				self.session.backend.host_updateObjects(host)
		
	def _setResponse(self, result):
		if not isinstance(result, http.Response):
			result = http.Response()
		result.code = responsecode.OK
		result.headers.setHeader('content-type', http_headers.MimeType("text", "html", {"charset": "utf-8"}))
		result.stream = stream.IByteStream("")
		return result

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                       CLASS JSON RPC                                              =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class JsonRpc(object):
	def __init__(self, worker, rpc):
		self._worker   = worker
		self.started   = None
		self.ended     = None
		self.type      = rpc.get('type')
		self.tid       = rpc.get('tid', rpc.get('id'))
		self.action    = rpc.get('action')
		self.method    = rpc.get('method')
		self.params    = rpc.get('params', rpc.get('data'))
		if not self.params:
			self.params = []
		self.result    = None
		self.exception = None
		self.traceback = None
		if not self.tid:
			raise Exception(u"No transaction id ((t)id) found in rpc")
		if not self.method:
			raise Exception(u"No method found in rpc")
	
	def isStarted(self):
		return bool(self.started)
	
	def hasEnded(self):
		return bool(self.ended)
	
	def getMethodName(self):
		if self.action:
			return u'%s_%s' % (self.action, self.method)
		return self.method
	
	def getDuration(self):
		if not self.started or not self.ended:
			return None
		return round(self.ended - self.started, 3)
		
	def execute(self):
		# Execute rpc
		logger.info(u"Executing: %s" % self.getMethodName())
		
		self.started = time.time()
		try:
			found = False
			params = []
			for p in self.params:
				params.append(p)
			keywords = {}
			for m in self._worker.session.interface:
				if (self.getMethodName() == m['name']):
					if m['keywords']:
						l = 0
						if m['args']:
							l += len(m['args'])
						if m['varargs']:
							l += len(m['varargs'])
						if (len(params) >= l):
							for (key, value) in params.pop(-1).items():
								keywords[str(key)] = deserialize(value)
					found = True
					break
			if not found:
				raise OpsiconfdRpcError(u"Method '%s' is not valid" % self.getMethodName())
			
			params = deserialize(params)
			backend = self._worker.session.backend
			if keywords:
				self.result = serialize( eval( "backend.%s(*params, **keywords)" % self.getMethodName() ) )
			else:
				self.result = serialize( eval( "backend.%s(*params)" % self.getMethodName() ) )
			
			logger.info(u'Got result')
			logger.debug2(self.result)
			
		except Exception, e:
			logger.logException(e)
			logger.error(u'Execution error: %s' % e)
			self.exception = e
			self.traceback = []
			tb = sys.exc_info()[2]
			while (tb != None):
				f = tb.tb_frame
				c = f.f_code
				self.traceback.append(u"     line %s in '%s' in file '%s'" % (tb.tb_lineno, c.co_name, c.co_filename))
				tb = tb.tb_next
			#self.result['error'] = { 'class': e.__class__.__name__, 'message': unicode(e) }
			#self.result['result'] = None
			#return
		self.ended = time.time()
		self._worker.opsiconfd.statistics().addRpcStatistic(self)
		
	def getResponse(self):
		response = {}
		if (self.type == 'rpc'):
			response['tid']    = self.tid
			response['action'] = self.action
			response['method'] = self.method
			if self.exception:
				response['type']    = 'exception'
				response['message'] = { 'class': self.exception.__class__.__name__, 'message': unicode(self.exception) }
				response['where']   = self.traceback
			else:
				response['type']   = 'rpc'
				response['result'] = self.result
		else:
			response['id'] = self.tid
			if self.exception:
				response['error']  = { 'class': self.exception.__class__.__name__, 'message': unicode(self.exception) }
				response['result'] = None
			else:
				response['error']  = None
				response['result'] = self.result
		return response

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                  CLASS WORKER OPSI JSON RPC                                       =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class WorkerOpsiJsonRpc(Worker):
	def __init__(self, opsiconfd, request, resource):
		Worker.__init__(self, opsiconfd, request, resource)
		self._rpcs = []
	
	def process(self):
		logger.info("Worker %s started processing" % self)
		deferred = defer.Deferred()
		deferred.addCallback(self._getSession)
		deferred.addCallback(self._linkLogFile)
		deferred.addCallback(self._authenticate)
		deferred.addCallback(self._getQuery)
		deferred.addCallback(self._decodeQuery)
		deferred.addCallback(self._getRpcs)
		deferred.addCallback(self._executeRpcs)
		deferred.addCallback(self._setResponse)
		deferred.addCallback(self._setCookie)
		deferred.addCallback(self._freeSession)
		deferred.addErrback(self._errback)
		deferred.callback(None)
		return deferred
	
	def _getRpcs(self, result):
		if not self.query:
			return result
		
		rpcs = []
		try:
			if hasattr(json, 'loads'):
				# Python 2.6 json module
				#rpcs = json.loads(self.query.replace(u'\ufffd', '?'))
				rpcs = json.loads(self.query)
			else:
				#rpcs = json.read(self.query.replace(u'\ufffd', '?'))
				rpcs = json.read(self.query)
			
			if not rpcs:
				raise Exception(u"Got no rpcs")
		
		except Exception, e:
			raise OpsiconfdBadRpcError(u"Failed to decode rpc: %s" % e)
		
		for rpc in forceList(rpcs):
			self._rpcs.append(JsonRpc(self, rpc))
		
		return result
	
	def _executeRpcs(self, result):
		if not self.session.backend:
			raise OpsiconfdError(u"Failed to get backend from session")
		deferred = None
		for rpc in self._rpcs:
			if rpc.hasEnded():
				continue
			if (rpc.getMethodName() == 'exit'):
				logger.notice(u"User '%s' asked to close the session" % self.session.user)
				self._freeSession(result)
				self.opsiconfd.getSessionHandler().deleteSession(self.session.uid)
				return result
			deferred = threads.deferToThread(rpc.execute)
			deferred.addCallback(self._executeRpcs)
			deferred.addErrback(self._errback)
			break
		if deferred:
			return deferred
		return result
	
	def _setResponse(self, result):
		if not isinstance(result, http.Response):
			result = http.Response()
		result.code = responsecode.OK
		result.headers.setHeader('content-type', http_headers.MimeType("application", "json", {"charset": "utf-8"}))
		response = []
		for rpc in self._rpcs:
			response.append(rpc.getResponse())
		if (len(response) == 1):
			response = response[0]
		if not response:
			response = None
		
		jsonResponse = None
		if hasattr(json, 'dumps'):
			# Python 2.6 json module
			jsonResponse = json.dumps(serialize(response))
		else:
			jsonResponse = json.write(serialize(response))
		result.stream = stream.IByteStream(jsonResponse)
		return result
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                               CLASS WORKER OPSI JSON INTERFACE                                    =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class WorkerOpsiJsonInterface(WorkerOpsiJsonRpc):
	def __init__(self, opsiconfd, request, resource):
		WorkerOpsiJsonRpc.__init__(self, opsiconfd, request, resource)
	
	def _setResponse(self, result):
		logger.info(u"Creating opsiconfd interface page")
		
		javascript  = u"var currentParams = new Array();\n"
		javascript += u"var currentMethod = null;\n"
		currentMethod = u''
		if self._rpcs:
			currentMethod = self._rpcs[0].getMethodName()
			javascript += u"currentMethod = '%s';\n" % currentMethod
			for i in range(len(self._rpcs[0].params)):
				param = self._rpcs[0].params[i]
				if hasattr(json, 'dumps'):
					# Python 2.6 json module
					param = json.dumps(param)
				else:
					params = json.write(param)
				javascript += u"currentParams[%d] = '%s';\n" % (i, param)
		
		selectMethod = u''
		for method in self.resource._interface:
			javascript += u"parameters['%s'] = new Array();\n" % (method['name'])
			for param in range(len(method['params'])):
				javascript += u"parameters['%s'][%s]='%s';\n" % (method['name'], param, method['params'][param])
			selected = u''
			if (method['name'] == currentMethod):
				selected = u' selected'
			selectMethod += '<option%s>%s</option>' % (selected, method['name'])
		
		resultDiv = u'<div id="result">'
		for rpc in self._rpcs:
			resultDiv += '<div class="json">'
			resultDiv += Tools.jsonObjToHtml(rpc.getResponse())
			resultDiv += u'</div>'
		resultDiv += u'</div>'
		
		html = interfacePage
		html = html.replace('%javascript%', javascript)
		html = html.replace('%select_method%', selectMethod)
		html = html.replace('%result%', resultDiv)
		
		if not isinstance(result, http.Response):
			result = http.Response()
		result.code = responsecode.OK
		result.stream = stream.IByteStream(html.encode('utf-8'))
		return result
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                 CLASS WORKER OPSICONFD INFO                                       =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class WorkerOpsiconfdInfo(Worker):
	def __init__(self, opsiconfd, request, resource):
		Worker.__init__(self, opsiconfd, request, resource)

	def _setResponse(self, result):
		logger.info(u"Creating opsiconfd info page")
		
		configInfo  = u'<h1>Server config</h1>'
		configInfo += u'<table>'
		configInfo += u'<tr><th>key</th><th>value</th></tr>'
		keys = self.opsiconfd.config.keys()
		keys.sort()
		for key in keys:
			if key in ('staticDirectories'):
				continue
			configInfo += u'<tr><td>%s</td><td>%s</td>' % (key, self.opsiconfd.config[key])
		configInfo += u'</table>'
		
		threads = []
		for thread in threading.enumerate():
			threads.append(thread)
		threadInfo  = u'<h1>Running threads (%d)</h1>' % len(threads)
		threadInfo += u'<table>'
		threadInfo += u'<tr><th>class</th><th>name</th><th>ident</th><th>alive</th></tr>'
		for thread in threads:
			threadInfo += u'<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>' % (thread.__class__.__name__, thread.name, thread.ident, thread.isAlive())
		threadInfo += u'</table>'
		
		sessions = self.opsiconfd.getSessionHandler().getSessions()
		sessionInfo  = u'<h1>Active sessions (%d)</h1>' % len(sessions.keys())
		sessionInfo += u'<table>'
		sessionInfo += u'<tr><th>created</th><th>last modified</th><th>validity</th><th>ip</th><th>hostname</th><th>user</th><th>is host</th><th>usage count</th><th>application</th></tr>'
		for session in sessions.values():
			sessionInfo += u'<tr><td>%s</td><td>%s</td><td>%ss</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>' \
				% (time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(session.created)), time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(session.lastModified)), \
					session.getValidity(), session.ip, session.hostname, session.user, session.isHost, session.usageCount, session.userAgent)
		sessionInfo += u'</table>'
		
		
		diskUsageInfo  = u'<h1>Disk usage</h1>'
		diskUsageInfo += u'<table>'
		diskUsageInfo += u'<tr><th>resource</th><th>path</th><th>capacity</th><th>used</th><th>available</th><th>usage</th></tr>'
		resources = self.opsiconfd.config['staticDirectories'].keys()
		resources.sort()
		for resource in resources:
			path = self.opsiconfd.config['staticDirectories'][resource]
			if os.path.isdir(path):
				if not resource.startswith('/'): resource = u'/' + resource
				info = getDiskSpaceUsage(path)
				diskUsageInfo += u'<tr><td><a href="%s">%s</a></td><td>%s</td><td>%0.2f GB</td><td>%0.2f GB</td><td>%0.2f GB</td><td>%0.2f %%</td></tr>' \
					% (resource, resource, path, (float(info['capacity'])/1073741824), (float(info['available'])/1073741824), (float(info['used'])/1073741824), (info['usage']*100))
		diskUsageInfo += u'</table>'
		
		#combinedRpcStatistsics = {}
		statisticInfo  = u'<h1>RPC statistics</h1>'
		statisticInfo += u'<table>'
		statisticInfo += u'<tr><th>method</th><th>params</th><th>results</th><th>duration</th><th>success</th></tr>'
		for statistic in sorted(self.opsiconfd.statistics().getRpcStatistics(), key=operator.itemgetter('method')):
			statisticInfo += u'<tr><td>%s</td><td>%d</td><td>%d</td><td>%0.3f s</td><td>%s</td></tr>' \
					% (statistic['method'], statistic['params'], statistic['results'], statistic['duration'], not statistic['failed'])
		statisticInfo += u'</table>'
		
		html = infoPage.replace('%time%', time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()))
		html = html.replace('%config_info%', configInfo)
		html = html.replace('%thread_info%', threadInfo)
		html = html.replace('%session_info%', sessionInfo)
		html = html.replace('%disk_usage_info%', diskUsageInfo)
		html = html.replace('%rpc_statistic_info%', statisticInfo)
		
		if not isinstance(result, http.Response):
			result = http.Response()
		result.code = responsecode.OK
		result.stream = stream.IByteStream(html.encode('utf-8'))
		return result





# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                        CLASS DAVWORKER                                            =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class WorkerOpsiDAV(Worker):
	def __init__(self, opsiconfd, request, resource):
		Worker.__init__(self, opsiconfd, request, resource)
	
	def process(self):
		logger.info("Worker %s started processing" % self)
		deferred = defer.Deferred()
		deferred.addCallback(self._getSession)
		deferred.addCallback(self._authenticate)
		deferred.addCallback(self._setResponse)
		deferred.addCallback(self._setCookie)
		deferred.addCallback(self._freeSession)
		deferred.addErrback(self._errback)
		deferred.callback(None)
		return deferred
		
	def _setResponse(self, result):
		logger.debug(u"Client requests DAV operation: %s" % self.request)
		deferred = super(ResourceOpsiDAV, self.resource).renderHTTP(self.request)
		if isinstance(deferred, defer.Deferred):
			deferred.addErrback(self._errback)
		return deferred


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                     CLASS RESOURCE ROOT                                           =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class ResourceRoot(resource.Resource):
	addSlash = True
	def render(self, request):
		''' Process request. '''
		return http.Response(stream="<html><head><title>opsiconfd</title></head><body></body></html>")

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                     CLASS RESOURCE OPSI                                           =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class ResourceOpsi(resource.Resource):
	WorkerClass = None
	
	def __init__(self, opsiconfd):
		resource.Resource.__init__(self)
		self._opsiconfd = opsiconfd
		
	def getChild(self, name, request):
		''' Get the child resource for the requested path. '''
		if not name:
			return self
		return resource.Resource.getChild(self, name, request)
	
	def renderHTTP(self, request):
		''' Process POST request. '''
		try:
			logger.debug2(u"%s.renderHTTP()" % self.__class__.__name__)
			if not self.WorkerClass:
				raise Exception(u"No worker class defined in resource %s" % self.__class__.__name__)
			worker = self.WorkerClass(self._opsiconfd, request, self)
			return worker.process()
		except Exception, e:
			logger.logException(e)
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                 CLASS RESOURCE OPSI JSONRPC                                       =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class ResourceOpsiJsonRpc(ResourceOpsi):
	WorkerClass = WorkerOpsiJsonRpc
	
	def __init__(self, opsiconfd):
		ResourceOpsi.__init__(self, opsiconfd)
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                              CLASS RESOURCE OPSI JSON INTERFACE                                   =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class ResourceOpsiJsonInterface(ResourceOpsiJsonRpc):
	WorkerClass = WorkerOpsiJsonInterface
	
	def __init__(self, opsiconfd):
		ResourceOpsiJsonRpc.__init__(self, opsiconfd)
		self._interface = self._opsiconfd.getBackend().getInterface()

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                CLASS RESOURCE OPSICONFD INFO                                      =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class ResourceOpsiconfdInfo(ResourceOpsi):
	WorkerClass = WorkerOpsiconfdInfo
	
	def __init__(self, opsiconfd):
		ResourceOpsi.__init__(self, opsiconfd)
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                   CLASS RESOURCE OPSI DAV                                         =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class ResourceOpsiDAV(static.DAVFile):
	
	def __init__(self, opsiconfd, path, readOnly=True, defaultType="text/plain", indexNames=None):
		path = forceUnicode(path).encode('utf-8')
		static.DAVFile.__init__(self, path, defaultType, indexNames)
		self._opsiconfd = opsiconfd
		self._readOnly = readOnly
	
	def createSimilarFile(self, path):
		return self.__class__(self._opsiconfd, path, readOnly=self._readOnly, defaultType=self.defaultType, indexNames=self.indexNames[:])
	
	def renderHTTP(self, request):
		try:
			if self._readOnly and request.method not in ('GET', 'PROPFIND'):
				logger.warning(u"Command %s not allowed (readonly)" % request.method)
				return http.Response(
					code	= responsecode.FORBIDDEN,
					stream	= "Readonly!" )
			worker = WorkerOpsiDAV(self._opsiconfd, request, self)
			return worker.process()
		except Exception, e:
			logger.logException(e)


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                      CLASS SSL CONTEXT                                            =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class SSLContext:
	def __init__(self, sslServerKeyFile, sslServerCertFile):
		self._sslServerKeyFile  = sslServerKeyFile
		self._sslServerCertFile = sslServerCertFile
		
	def getContext(self):
		''' Create an SSL context. '''
		
		# Test if server certificate and key file exist.
		if not os.path.isfile(self._sslServerKeyFile):
			raise Exception(u"Server key file '%s' does not exist!" % self._sslServerKeyFile)
			
		if not os.path.isfile(self._sslServerCertFile):
			raise Exception(u"Server certificate file '%s' does not exist!" % self._sslServerCertFile)
		
		context = SSL.Context(SSL.SSLv23_METHOD)
		context.use_privatekey_file(self._sslServerKeyFile)
		context.use_certificate_file(self._sslServerCertFile)
		return context

	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                         CLASS SESSION                                             =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class Session:
	def __init__(self, sessionHandler, name = u'OPSISID', sessionMaxInactiveInterval = 120):
		self.sessionHandler = sessionHandler
		self.name = forceUnicode(name)
		self.sessionMaxInactiveInterval = forceInt(sessionMaxInactiveInterval)
		self.created = time.time()
		self.lastModified = time.time()
		self.sessionTimer = None
		self.uid = Tools.randomString(32)
		self.ip = ''
		self.userAgent = ''
		self.isHost = False
		self.hostname = ''
		self.user = ''
		self.password = ''
		self.authenticated = False
		self.backend = None
		self.interface = None
		self.usageCount = 0
		self.usageCountLock = threading.Lock()
		self.deleted = False
		self.touch()
		
	def decreaseUsageCount(self):
		if self.deleted:
			return
		self.usageCountLock.acquire()
		self.usageCount -= 1
		self.usageCountLock.release()
		
	def increaseUsageCount(self):
		if self.deleted:
			return
		self.usageCountLock.acquire()
		self.usageCount += 1
		self.touch()
		self.usageCountLock.release()
	
	def touch(self):
		if self.deleted:
			return
		self.lastModified = time.time()
		if self.sessionTimer:
			self.sessionTimer.cancel()
			self.sessionTimer.join(1)
		self.sessionTimer = threading.Timer(self.sessionMaxInactiveInterval, self.expire)
		self.sessionTimer.start()
		
	def getValidity(self):
		if self.deleted:
			return 0
		return int(self.lastModified - time.time() + self.sessionMaxInactiveInterval)
	
	def expire(self):
		self.sessionHandler.sessionExpired(self)
	
	def delete(self):
		if self.deleted:
			return
		self.deleted = True
		if (self.usageCount > 0):
			logger.warning(u"Deleting session in use: %s" % self)
		if self.sessionTimer:
			try:
				self.sessionTimer.cancel()
				try:
					self.sessionTimer.join(1)
				except:
					pass
				logger.info(u"Session timer %s canceled" % self.sessionTimer)
			except Exception, e:
				logger.error(u"Failed to cancel session timer: %s" % e)
		if session.backend:
			logger.debug(u"Calling exit() on backend %s" % session.backend)
			session.backend.exit()
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                    CLASS SESSION HANDLER                                          =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class SessionHandler:
	def __init__(self, sessionName = 'OSPISID', sessionMaxInactiveInterval = 120):
		self.sessionName = sessionName
		self.sessionMaxInactiveInterval = sessionMaxInactiveInterval
		self.sessions = {}
	
	def cleanup(self):
		self.deleteAllSessions()
	
	def getSessions(self):
		return self.sessions
		
	def getSession(self, uid):
		if uid:
			session = self.sessions.get(uid)
			if session:
				return session
			else:
				logger.info(u'Failed to get session: session id %s not found' % uid)
		return self.createSession()
	
	def createSession(self):
		session = Session(self, self.sessionName, self.sessionMaxInactiveInterval)
		self.sessions[session.uid] = session
		logger.notice(u"New session created")
		return session
	
	def sessionExpired(self, session):
		logger.notice(u"Session '%s' from ip '%s', application '%s' expired after %d seconds" \
				% (session.uid, session.ip, session.userAgent, (time.time()-session.lastModified)))
		if (session.usageCount > 0):
			logger.notice(u"Session currently in use, waiting before deletion")
		while (session.usageCount > 0):
			time.sleep(1)
		self.deleteSession(session.uid)
		
	def deleteSession(self, uid):
		session = self.sessions.get(uid)
		if not session:
			logger.warning(u'No such session id: %s' % uid)
			return
		
		try:
			session.delete()
		except:
			pass
		
		try:
			del self.sessions[uid]
			logger.notice(u"Session '%s' from ip '%s', application '%s' deleted" % (session.uid, session.ip, session.userAgent))
			del session
		except KeyError:
			pass
	
	def deleteAllSessions(self):
		logger.notice(u"Deleting all sessions")
		for (uid, session) in self.sessions.items():
			logger.notice(u"Deleting session '%s'" % uid)
			self.deleteSession(uid)
		self.sessions = {}

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                       CLASS STATISTICS                                            =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class Statistics(object):
	def __init__(self, maxExecutionStatisticValues=250):
		self._maxExecutionStatisticValues = maxExecutionStatisticValues
		self._rpcStatistics = []
	
	def addRpcStatistic(self, jsonrpc):
		results = 0
		if not jsonrpc.exception:
			results = 0
			if type(jsonrpc.result) is list:
				results = len(jsonrpc.result)
		
		self._rpcStatistics.append({
			'duration': jsonrpc.ended - jsonrpc.started,
			'method':   jsonrpc.getMethodName(),
			'failed':   bool(jsonrpc.exception),
			'params':   len(jsonrpc.params),
			'results':  results,
		})
		if (len(self._rpcStatistics) > self._maxExecutionStatisticValues):
			self._rpcStatistics = self._rpcStatistics[1:]
					
	def getRpcStatistics(self):
		return self._rpcStatistics
	
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                       CLASS OPSICONFD                                             =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class Opsiconfd(threading.Thread):
	def __init__(self, config):
		threading.Thread.__init__(self)
		
		self.config          = config
		self._running        = False
		
		self._backend        = None
		self._root           = None
		self._site           = None
		self._httpPort       = None
		self._httpsPort      = None
		self._sessionHandler = None
		self._statistics     = None
		
		self._setOpsiLogging()
		self._setTwistedLogging()
		logger.comment(	"\n==================================================================\n" \
				+ "=             OPSI configuration-service starting                =\n" \
				+ "==================================================================\n")
		
	def setConfig(self, config):
		logger.notice(u"Got new config")
		self.config = config
		
	def isRunning(self):
		return self._running
	
	def getBackend(self):
		return self._backend
	
	def statistics(self):
		return self._statistics
		
	def getSessionHandler(self):
		return self._sessionHandler
	
	def stop(self):
		logger.notice(u"Stopping opsiconfd main thread")
		if self._httpPort:
			self._httpPort.stopListening()
		if self._httpsPort:
			self._httpsPort.stopListening()
		if self._sessionHandler:
			self._sessionHandler.cleanup()
		if reactor.running:
			try:
				logger.notice(u"Stopping reactor")
				reactor.stop()
			except Exception, e:
				logger.error(u"Failed to stop reactor: %s" % e)
		self._running = False
	
	def reload(self):
		logger.notice(u"Reloading opsiconfd")
		self._setOpsiLogging()
		self._createBackendInstance()
		if self._sessionHandler:
			self._sessionHandler.cleanup()
		self._createSessionHandler()
		self._createStatistics()
		self._createSite()
		
		if self._httpPort:
			deferred = self._httpPort.stopListening()
			if deferred:
				deferred.addCallback(self._startListeningHTTP)
		else:
			self._startListeningHTTP()
		
		if self._httpsPort:
			deferred = self._httpsPort.stopListening()
			if deferred:
				deferred.addCallback(self._startListeningHTTPS)
		else:
			self._startListeningHTTPS()
		
	def _createStatistics(self):
		self._statistics = Statistics(maxExecutionStatisticValues = self.config['maxExecutionStatisticValues'])
		
	def _createSessionHandler(self):
		self._sessionHandler = SessionHandler(
			sessionName                = self.config['sessionName'],
			sessionMaxInactiveInterval = self.config['sessionMaxInactiveInterval']
		)
	
	def _setOpsiLogging(self):
		# Set logging options
		self.config['machineLogs'] = False
		if self.config['logFile']:
			if (self.config['logFile'].find('%m') != -1):
				self.config['machineLogs'] = True
			logger.setLogFile( self.config['logFile'].replace('%m', 'opsiconfd') )
		
		if self.config['logFormat']:
			logger.setLogFormat(self.config['logFormat'])
		logger.setFileLevel(self.config['logLevel'])
	
	def _setTwistedLogging(self):
		def twistedLogObserver(eventDict):
			if eventDict.get('isError'):
				if eventDict.get('failure'):
					logger.logTraceback(eventDict['failure'].getTracebackObject())
					logger.critical(u"     ==>>> %s" % eventDict['failure'].getErrorMessage())
				for line in eventDict.get('message', ()):
					logger.error(line)
			else:
				for line in eventDict.get('message', ()):
					logger.debug(u"[twisted] %s" % line)
		
		log.startLoggingWithObserver(twistedLogObserver, setStdout=0)
	
	def _createBackendInstance(self):
		logger.info(u"Creating backend instance")
		self._backend = BackendManager(
			dispatchConfigFile = self.config['dispatchConfigFile'],
			backendConfigDir   = self.config['backendConfigDir'],
			extensionConfigDir = self.config['extensionConfigDir'],
			#aclFile            = self.config['aclFile']
		)
	
	def _createSite(self):
		logger.info(u"Creating site")
		del self._site
		del self._root
		
		if self.config['staticDirectories'].get('/'):
			if not os.path.isdir(self.config['staticDirectories']['/']):
				logger.error(u"Cannot add static content '/': directory '%s' does not exist." \
					% staticDirectories.get('/'))
			else:
				self._root = static.File(self.config['staticDirectories']['/'])
				logger.notice(u"Added static content '/' which points to directory '%s'" \
					% self.config['staticDirectories']['/'])
		
		if not self._root:
			self._root = ResourceRoot()
		
		self._root.putChild('rpc',       ResourceOpsiJsonRpc(self))
		self._root.putChild('interface', ResourceOpsiJsonInterface(self))
		self._root.putChild('info',      ResourceOpsiconfdInfo(self))
		
		for (name, path) in self.config['staticDirectories'].items():
			if (name == '/'):
				continue
			
			if name in ('rpc', 'interface', 'info', 'depot', 'repository'):
				logger.error(u"Cannot add static content '%s', already in use!" % name)
				continue
			
			if not os.path.isdir(path):
				logger.error(u"Cannot add static content '%s': directory '%s' does not exist." % (name, path))
				continue
			
			if (name == 'configed'):
				self._root.putChild(name, static.File(path))
				logger.notice(u"Added static content '%s' which points to directory '%s'" % (name, path))
				continue
			
			self._root.putChild(name, ResourceOpsiDAV(self, path, readOnly=True))
			logger.notice(u"Added webdav content '%s' which points to directory '%s'" % (name, path))
		
		hosts = self._backend.host_getObjects(type = 'OpsiDepotserver', id = self.config['fqdn'])
		if hosts:
			depot = hosts[0]
			self.config['depotId'] = depot.getId()
			logger.notice(u"Running on depot server '%s', exporting repository directory" % self.config['depotId'])
			if not depot.getRepositoryLocalUrl():
				raise Exception(u"Repository local url for depot '%s' not found" % self.config['depotId'])
			if not depot.getRepositoryLocalUrl().startswith('file:///'):
				raise Exception(u"Repository local url '%s' not allowed" % depot.getRepositoryLocalUrl())
			path = depot.getRepositoryLocalUrl()[7:]
			if not os.path.isdir(path):
				raise Exception(u"Cannot add webdav content 'repository': directory '%s' does not exist." % path)
			if not os.access(path, os.R_OK | os.W_OK | os.X_OK):
				raise Exception(u"Cannot add webdav content 'repository': permissions on directory '%s' not sufficient." % path)
			
			self._root.putChild('repository', ResourceOpsiDAV(self, path, readOnly=False))
			logger.notice(u"Added static content 'repository' which points to directory '%s'" % path)
			
			logger.notice(u"Running on depot server '%s', exporting depot directory" % self.config['depotId'])
			if not depot.getDepotLocalUrl():
				raise Exception(u"Repository local url for depot '%s' not found" % self.config['depotId'])
			if not depot.getDepotLocalUrl().startswith('file:///'):
				raise Exception(u"Repository local url '%s' not allowed" % depot.getDepotLocalUrl())
			path = depot.getDepotLocalUrl()[7:]
			if not os.path.isdir(path):
				raise Exception(u"Cannot add webdav content 'depot': directory '%s' does not exist." % path)
			if not os.access(path, os.R_OK | os.W_OK | os.X_OK):
				raise Exception(u"Cannot add webdav content 'depot': permissions on directory '%s' not sufficient." % path)
			
			self._root.putChild('depot', ResourceOpsiDAV(self, path, readOnly=True))
			logger.notice(u"Added static content 'depot' which points to directory '%s'" % path)
		
		self._site = server.Site(self._root)
	
	def _startListening(self):
		logger.info(u"Creating ports")
		self._startListeningHTTP()
		self._startListeningHTTPS()
		
	def _startListeningHTTP(self, dontcare=None):
		if (self.config['httpPort'] <= 0):
			self._httpPort = None
			return
		
		if (self.config['interface'] == '0.0.0.0'):
			self._httpPort = reactor.listenTCP(
				self.config['httpPort'],
				HTTPFactory(self._site)
			)
		else:
			self._httpPort = reactor.listenTCP(
				self.config['httpPort'],
				HTTPFactory(self._site),
				interface = self.config['interface']
			)
		
		logger.notice(u"Accepting HTTP requests on %s:%s" % (self.config['interface'], self.config['httpPort']))
	
	def _startListeningHTTPS(self, dontcare=None):
		if (self.config['httpsPort'] <= 0):
			self._httpsPort = None
			return
	
		if (self.config['interface'] == '0.0.0.0'):
			self._httpsPort = reactor.listenSSL(
				self.config['httpsPort'],
				HTTPFactory(self._site),
				SSLContext(self.config['sslServerKeyFile'], self.config['sslServerCertFile'])
			)
		else:
			self._httpsPort = reactor.listenSSL(
				self.config['httpsPort'],
				HTTPFactory(self._site),
				SSLContext(self.config['sslServerKeyFile'], self.config['sslServerCertFile']),
				interface = self.config['interface']
			)
		
		logger.notice(u"Accepting HTTPS requests on %s:%s" % (self.config['interface'], self.config['httpsPort']))
		
	def run(self):
		self._running = True
		logger.notice(u"Starting opsiconfd main thread")
		try:
			self._createBackendInstance()
			self._createSessionHandler()
			self._createStatistics()
			self._createSite()
			self._startListening()
			
			if not reactor.running:
				reactor.run(installSignalHandlers=0)
			
			logger.notice(u"Opsiconfd main thread exiting...")
		except Exception, e:
			logger.logException(e)
		self._running = False
	
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# -                                           OPSICONFD INIT                                          -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class OpsiconfdInit(object):
	def __init__(self):
		logger.debug(u"OpsiconfdInit")
		# Set umask
		os.umask(0077)
		self._pid = 0
		
		try:
			(self.opts, self.args) = getopt.getopt(sys.argv[1:], "vc:f:l:p:P:i:D")
		except getopt.GetoptError:
			self.usage()
			sys.exit(1)
		
		self.setDefaultConfig()
		# Process command line arguments
		for (opt, arg) in self.opts:
			if (opt == "-c"):
				self.config['configFile'] = forceFilename(arg)
			if   (opt == "-v"):
				print u"opsiconfd version %s" % __version__
				sys.exit(0)
		self.readConfigFile()
		self.setCommandlineConfig()
		
		# Call signalHandler on signal SIGHUP, SIGTERM, SIGINT
		signal(SIGHUP,  self.signalHandler)
		signal(SIGTERM, self.signalHandler)
		signal(SIGINT,  self.signalHandler)
		
		if self.config['daemon']:
			logger.setConsoleLevel(LOG_NONE)
			self.daemonize()
		else:
			logger.setConsoleLevel(self.config['logLevel'])
			logger.setConsoleColor(True)
		
		self.createPidFile()
		
		# Start opsiconfd
		self._opsiconfd = Opsiconfd(self.config)
		self._opsiconfd.start()
		time.sleep(3)
		while self._opsiconfd.isRunning():
			time.sleep(1)
		self._opsiconfd.join(30)
		self.removePidFile()
	
	def setDefaultConfig(self):
		self.config = {
			'pidFile'                      : u'/var/run/opsiconfd/opsiconfd.pid',
			'configFile'                   : u'/etc/opsi/opsiconfd.conf',
			'daemon'                       : False,
			'logLevel'                     : LOG_NOTICE,
			'logFile'                      : u'/var/log/opsi/opsiconfd/opsiconfd.log',
			'logFormat'                    : u'[%l] [%D] %M (%F|%N)',
			'symlinkLogs'                  : False,
			'httpPort'                     : 0,
			'httpsPort'                    : 4447,
			'interface'                    : u'0.0.0.0',
			'backendManagerConf'           : None,
			'maxExecutionStatisticValues'  : 250,
			'sslServerCertFile'            : u'/etc/opsi/opsiconfd.pem',
			'sslServerKeyFile'             : u'/etc/opsi/opsiconfd.pem',
			'sessionName'                  : u'OPSISID',
			'resolveClientIp'              : True,
			'resolveVerifyIp'              : False,
			'sessionMaxInactiveInterval'   : 120,
			'updateHardwareAddress'        : True,
			'staticDirectories'            : {},
			'depotId'                      : None,
			'fqdn'                         : socket.getfqdn(),
			'backendConfigDir'             : u'/etc/opsi/backends',
			'dispatchConfigFile'           : u'/etc/opsi/backendManager/dispatch.conf',
			'extensionConfigDir'           : u'/etc/opsi/backendManager/compose.d',
			'aclFile '                     : u'/etc/opsi/backendManager/acl.conf'
		}
	
	def setCommandlineConfig(self):
		for (opt, arg) in self.opts:
			if   (opt == "-D"):
				self.config['daemon'] = True
			elif (opt == "-l"):
				self.config['logLevel'] = forceInt(arg)
			elif (opt == "-f"):
				self.config['logFile'] = forceFilename(arg)
			elif (opt == "-p"):
				self.config['httpPort'] = forceInt(arg)
			elif (opt == "-P"):
				self.config['httpsPort'] = forceInt(arg)
			elif (opt == "-i"):
				self.config['interface'] = forceUnicode(arg)
		
	def createPidFile(self):
		logger.info(u"Creating pid file '%s'" % self.config['pidFile'])
		if os.path.exists(self.config['pidFile']):
			pf = open(self.config['pidFile'], 'r')
			p = pf.readline().strip()
			pf.close()
			if p:
				running = False
				try:
					for i in execute("%s -x opsiconfd" % which("pidof"))[0].strip().split():
						if (i == p):
							running = True
							break
				except Exception, e:
					logger.error(e)
				if running:
					raise Exception(u"Another opsiconfd process is running (pid: %s), stop process first or change pidfile." % p )
				
		pid = os.getpid()
		pf = open (self.config['pidFile'], "w")
		print >> pf, str(pid)
		pf.close()
	
	def removePidFile(self):
		try:
			# if (self._pid == os.getpid())
			if os.path.exists(self.config['pidFile']):
				logger.info(u"Removing pid file '%s'" % self.config['pidFile'])
				os.unlink(self.config['pidFile'])
		except Exception, e:
			logger.error(u"Failed to remove pid file '%s': %s" % (self.config['pidFile'], e))
		
	def signalHandler(self, signo, stackFrame):
		for thread in threading.enumerate():
			logger.debug(u"Running thread before signal: %s" % thread)
		
		if (signo == SIGHUP):
			if reactor and reactor.running and self._opsiconfd:
				self.setDefaultConfig()
				self.readConfigFile()
				self.setCommandlineConfig()
				self._opsiconfd.setConfig(self.config)
				reactor.callFromThread(self._opsiconfd.reload)
		
		if (signo == SIGTERM or signo == SIGINT):
			if reactor and reactor.running and self._opsiconfd:
				reactor.callFromThread(self._opsiconfd.stop)
				
		for thread in threading.enumerate():
			logger.debug(u"Running thread after signal: %s" % thread)
		
	def readConfigFile(self):
		''' Get settings from config file '''
		logger.notice(u"Trying to read config from file: '%s'" % self.config['configFile'])
		
		try:
			iniFile = IniFile(filename = self.config['configFile'], raw = True)
			config = iniFile.parse()
			
			for section in config.sections():
				logger.debug(u"Processing section '%s' in config file: '%s'" % (section, self.config['configFile']))
				if (section.lower() == 'global'):
					# Global settings
					for (option, value) in config.items(section):
						if   (option == 'bm config'):
							self.config['backendManagerConf'] = forceFilename(value)
						elif (option == 'pid file'):
							self.config['pidFile'] = forceFilename(value)
						elif (option == 'log level'):
							self.config['logLevel'] = forceInt(value)
						elif (option == 'log file'):
							self.config['logFile'] = forceFilename(value)
						elif (option == 'log format'):
							self.config['logFormat'] = forceUnicode(value)
						elif (option == 'symlink logs'):
							self.config['symlinkLogs'] = forceBool(value)
						elif (option == 'max execution statistics'):
							self.config['maxExecutionStatisticValues'] = forceInt(value)
						else:
							logger.warning(u"Ignoring unknown option '%s' in config file: '%s'" % (option, self.config['configFile']))
				
				elif (section.lower() == 'service'):
					# Service settings
					for (option, value) in config.items(section):
						if   (option == 'http port'):
							self.config['httpPort'] = forceInt(value)
						elif (option == 'https port'):
							self.config['httpsPort'] = forceInt(value)
						elif (option == 'interface'):
							self.config['interface'] = forceUnicode(value)
						elif (option == 'ssl server cert'):
							self.config['sslServerCertFile'] = forceFilename(value)
						elif (option == 'ssl server key'):
							self.config['sslServerKeyFile'] = forceFilename(value)
						else:
							logger.warning(u"Ignoring unknown option '%s' in config file: '%s'" % (option, self.config['configFile']))
				
				elif (section.lower() == 'session'):
					# Session settings
					for (option, value) in config.items(section):
						if   (option == 'session name'):
							self.config['sessionName'] = forceUnicode(value)
						elif (option == 'resolve ip'):
							self.config['resolveClientIp'] = forceBool(value)
						elif (option == 'verify ip'):
							self.config['resolveVerifyIp'] = forceBool(value)
						elif (option == 'max inactive interval'):
							self.config['sessionMaxInactiveInterval'] = forceInt(value)
						elif (option == 'update hardware address'):
							self.config['updateHardwareAddress'] = forceBool(value)
						else:
							logger.warning(u"Ignoring unknown option '%s' in config file: '%s'" % (option, self.config['configFile']))
				
				elif (section.lower() == 'directories'):
					# Static directories
					self.config['staticDirectories'] = {}
					for (option, value) in config.items(section):
						self.config['staticDirectories'][option] = forceFilename(value)
				else:
					logger.warning(u"Ignoring unknown section '%s' in config file: '%s'" % (section, self.config['configFile']))
		
		except Exception, e:
			# An error occured while trying to read the config file
			logger.error(u"Failed to read config file '%s': %s" % (self.config['configFile'], e))
			logger.logException(e)
			raise
		logger.notice(u"Config read")
		
	def usage(self):
		print u"\nUsage: %s [-D] [-c <filename>] [-f <filename>] [-l <log level>] [-i <ipaddress>] [-p <http port>] [-P <https port>]" % os.path.basename(sys.argv[0])
		print u"Options:"
		print u"  -v    Show version information and exit"
		print u"  -D    Causes the server to operate as a daemon"
		print u"  -p    HTTP Port to listen on (0 to disable)"
		print u"  -P    HTTPS Port to listen on (0 to disable)"
		print u"  -i    IP address of interface to listen on (default: 0.0.0.0)"
		print u"  -f    Log to given file instead of syslog"
		print u"  -c    Location of config file"
		print u"  -l    Set log level (default: 4)"
		print u"        0=nothing, 1=critical, 2=error, 3=warning, 4=notice, 5=info, 6=debug, 7=debug2, 9=confidential"
		print u""
	
	def daemonize(self):
		# Fork to allow the shell to return and to call setsid
		try:
			self._pid = os.fork()
			if (self._pid > 0):
				# Parent exits
				sys.exit(0)
		except OSError, e:
			raise Exception(u"First fork failed: %e" % e)
		
		# Do not hinder umounts
		os.chdir("/")
		# Create a new session
		os.setsid()
		
		# Fork a second time to not remain session leader
		try:
			self._pid = os.fork()
			if (self._pid > 0):
				sys.exit(0)
		except OSError, e:
			raise Exception(u"Second fork failed: %e" % e)
		
		logger.setConsoleLevel(LOG_NONE)
		
		# Close standard output and standard error.
		os.close(0)
		os.close(1)
		os.close(2)
		
		# Open standard input (0)
		if (hasattr(os, "devnull")):
			os.open(os.devnull, os.O_RDWR)
		else:
			os.open("/dev/null", os.O_RDWR)
		
		# Duplicate standard input to standard output and standard error.
		os.dup2(0, 1)
		os.dup2(0, 2)
		sys.stdout = logger.getStdout()
		sys.stderr = logger.getStderr()

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# -                                               MAIN                                                -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if (__name__ == "__main__"):
	logger.setConsoleLevel(LOG_WARNING)
	exception = None
	
	try:
		OpsiconfdInit()
		
	except SystemExit, e:
		pass
		
	except Exception, e:
		exception = e
	
	if exception:
		logger.logException(exception)
		print >> sys.stderr, u"ERROR:", unicode(exception)
		sys.exit(1)
	sys.exit(0)



