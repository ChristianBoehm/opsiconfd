#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
   = = = = = = = = = = = = = = = = = = = = = = =
   =   opsi configuration daemon (opsiconfd)   =
   = = = = = = = = = = = = = = = = = = = = = = =
   
   opsiconfd is part of the desktop management solution opsi
   (open pc server integration) http://www.opsi.org
   
   Copyright (C) 2008 uib GmbH
   
   http://www.uib.de/
   
   All rights reserved.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License version 2 as
   published by the Free Software Foundation.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   
   @copyright:	uib GmbH <info@uib.de>
   @author: Jan Schneider <j.schneider@uib.de>
   @license: GNU General Public License version 2
"""

import os, sys, getopt, threading, time
from signal import *

from OPSI.Logger import *
from OPSI.Util.File import IniFile
from OPSI.Types import *
from OPSI.System import which, execute

logger = Logger()
logger.setConsoleLevel(100)

__version__ = '3.4.99'


class Opsiconfd(threading.Thread):
	def __init__(self, config):
		threading.Thread.__init__(self)
		
		self.config = config
		self._running = False
		self._stopped = False
		
		self.setLogging()
		logger.comment(	"\n==================================================================\n" \
				+ "=             OPSI configuration-service starting                =\n" \
				+ "==================================================================\n")
		
	def isRunning(self):
		return self._running
	
	def stop(self):
		logger.notice(u"Stopping opsiconfd main thread")
		self._stopped = True
		
	def setLogging(self):
		# Set logging options
		if self.config['logFile']:
			logger.setLogFile(self.config['logFile'])
		if self.config['logFormat']:
			logger.setLogFormat(self.config['logFormat'])
		logger.setFileLevel(self.config['logLevel'])
	
	def run(self):
		self._running = True
		logger.notice(u"Starting opsiconfd main thread")
		try:
			while not self._stopped:
				logger.comment(u"Running")
				time.sleep(1)
		except Exception, e:
			logger.logException(e)
		self._running = False
	
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# -                                           OPSICONFD INIT                                          -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class OpsiconfdInit(object):
	def __init__(self):
		logger.debug(u"OpsiconfdInit")
		# Set umask
		os.umask(0077)
		
		self._pid = 0
		self.config = {
			'pidFile'                      : u'/var/run/opsiconfd/opsiconfd.pid',
			'configFile'                   : u'/etc/opsi/opsiconfd.conf',
			'daemon'                       : False,
			'logLevel'                     : LOG_NOTICE,
			'logFile'                      : u'/var/log/opsi/opsiconfd/opsiconfd.log',
			'logFormat'                    : u'[%l] [%D] %M (%F|%N)',
			'symlinkLogs'                  : False,
			'httpPort'                     : 0,
			'httpsPort'                    : 4447,
			'interface'                    : u'0.0.0.0',
			'backendManagerConf'           : None,
			'maxExecutionStatisticValues'  : 250,
			'sslServerCertFile'            : u'/etc/opsi/opsiconfd.pem',
			'sslServerKeyFile'             : u'/etc/opsi/opsiconfd.pem',
			'sessionName'                  : u'OPSISID',
			'resolveClientIp'              : True,
			'resolveVerifyIp'              : False,
			'sessionMaxInactiveInterval'   : 120,
			'updateHardwareAddress'        : True,
			'staticDirectories'            : {},
		}
		
		argv = sys.argv[1:]
		
		# Call signalHandler on signal SIGHUP, SIGTERM, SIGINT
		signal(SIGHUP,  self.signalHandler)
		signal(SIGTERM, self.signalHandler)
		signal(SIGINT,  self.signalHandler)
		
		# Process command line arguments
		try:
			(opts, args) = getopt.getopt(argv, "vc:f:l:p:P:i:D")
		
		except getopt.GetoptError:
			self.usage()
			sys.exit(1)
		
		for (opt, arg) in opts:
			if (opt == "-c"):
				self.config['configFile'] = forceFilename(arg)
		
		self.readConfigFile()
		
		for (opt, arg) in opts:
			if   (opt == "-v"):
				print u"opsiconfd version %s" % __version__
				sys.exit(0)
			if   (opt == "-D"):
				self.config['daemon'] = True
			elif (opt == "-l"):
				self.config['logLevel'] = forceInt(arg)
			elif (opt == "-f"):
				self.config['logFile'] = forceFilename(arg)
			elif (opt == "-p"):
				self.config['httpPort'] = forceInt(arg)
			elif (opt == "-P"):
				self.config['httpsPort'] = forceInt(arg)
			elif (opt == "-i"):
				self.config['interface'] = forceUnicode(arg)
		
		if self.config['daemon']:
			logger.setConsoleLevel(LOG_NONE)
			self.daemonize()
		else:
			logger.setConsoleLevel(self.config['logLevel'])
			logger.setConsoleColor(True)
		
		self.createPidFile()
		
		# Start opsiconfd
		self._opsiconfd = Opsiconfd(self.config)
		self._opsiconfd.start()
		#self._opsiconfd.join()
		while self._opsiconfd.isRunning():
			time.sleep(1)
			
		self.removePidFile()
		
		
	def createPidFile(self):
		logger.info(u"Creating pid file '%s'" % self.config['pidFile'])
		if os.path.exists(self.config['pidFile']):
			pf = open(self.config['pidFile'], 'r')
			p = pf.readline().strip()
			pf.close()
			if p:
				running = False
				try:
					for i in execute("%s -x opsiconfd" % which("pidof"))[0].strip().split():
						if (i == p):
							running = True
							break
				except Exception, e:
					logger.error(e)
				if running:
					raise Exception(u"Another opsiconfd process is running (pid: %s), stop process first or change pidfile." % p )
				
		pid = os.getpid()
		pf = open (self.config['pidFile'], "w")
		print >> pf, str(pid)
		pf.close()
	
	def removePidFile(self):
		try:
			# if (self._pid == os.getpid())
			if os.path.exists(self.config['pidFile']):
				logger.info(u"Removing pid file '%s'" % self.config['pidFile'])
				os.unlink(self.config['pidFile'])
		except Exception, e:
			logger.error(u"Failed to remove pid file '%s': %s" % (self.config['pidFile'], e))
		
	def signalHandler(self, signo, stackFrame):
		if (signo == SIGHUP):
			return
		if (signo == SIGTERM or signo == SIGINT):
			self._opsiconfd.stop()
	
	def readConfigFile(self):
		''' Get settings from config file '''
		logger.notice(u"Trying to read config from file: '%s'" % self.config['configFile'])
		
		try:
			iniFile = IniFile(filename = self.config['configFile'], raw = True)
			config = iniFile.parse()
			
			for section in config.sections():
				logger.debug(u"Processing section '%s' in config file: '%s'" % (section, self.config['configFile']))
				if (section.lower() == 'global'):
					# Global settings
					for (option, value) in config.items(section):
						if   (option == 'bm config'):
							self.config['backendManagerConf'] = forceFilename(value)
						elif (option == 'pid file'):
							self.config['pidFile'] = forceFilename(value)
						elif (option == 'log level'):
							self.config['logLevel'] = forceInt(value)
						elif (option == 'log file'):
							self.config['logFile'] = forceFilename(value)
						elif (option == 'log format'):
							self.config['logFormat'] = forceUnicode(value)
						elif (option == 'symlink logs'):
							self.config['symlinkLogs'] = forceBool(value)
						elif (option == 'max execution statistics'):
							self.config['maxExecutionStatisticValues'] = forceInt(value)
						else:
							logger.warning(u"Ignoring unknown option '%s' in config file: '%s'" % (option, self.config['configFile']))
				
				elif (section.lower() == 'service'):
					# Service settings
					for (option, value) in config.items(section):
						if   (option == 'http port'):
							self.config['httpPort'] = forceInt(value)
						elif (option == 'https port'):
							self.config['httpsPort'] = forceInt(value)
						elif (option == 'interface'):
							self.config['interface'] = forceUnicode(value)
						elif (option == 'ssl server cert'):
							self.config['sslServerCertFile'] = forceFilename(value)
						elif (option == 'ssl server key'):
							self.config['sslServerKeyFile'] = forceFilename(value)
						else:
							logger.warning(u"Ignoring unknown option '%s' in config file: '%s'" % (option, self.config['configFile']))
				
				elif (section.lower() == 'session'):
					# Session settings
					for (option, value) in config.items(section):
						if   (option == 'session name'):
							self.config['sessionName'] = forceUnicode(value)
						elif (option == 'resolve ip'):
							self.config['resolveClientIp'] = forceBool(value)
						elif (option == 'verify ip'):
							self.config['resolveVerifyIp'] = forceBool(value)
						elif (option == 'max inactive interval'):
							self.config['sessionMaxInactiveInterval'] = forceInt(value)
						elif (option == 'update hardware address'):
							self.config['updateHardwareAddress'] = forceBool(value)
						else:
							logger.warning(u"Ignoring unknown option '%s' in config file: '%s'" % (option, self.config['configFile']))
				
				elif (section.lower() == 'directories'):
					# Static directories
					self.config['staticDirectories'] = {}
					for (option, value) in config.items(section):
						self.config['staticDirectories'][option] = forceFilename(value)
				else:
					logger.warning(u"Ignoring unknown section '%s' in config file: '%s'" % (section, self.config['configFile']))
		
		except Exception, e:
			# An error occured while trying to read the config file
			logger.error(u"Failed to read config file '%s': %s" % (self.config['configFile'], e))
			logger.logException(e)
			raise
		logger.notice(u"Config read")
		
	def usage(self):
		print u"\nUsage: %s [-D] [-c <filename>] [-f <filename>] [-l <log level>] [-i <ipaddress>] [-p <http port>] [-P <https port>]" % os.path.basename(sys.argv[0])
		print u"Options:"
		print u"  -v    Show version information and exit"
		print u"  -D    Causes the server to operate as a daemon"
		print u"  -p    HTTP Port to listen on (0 to disable)"
		print u"  -P    HTTPS Port to listen on (0 to disable)"
		print u"  -i    IP address of interface to listen on (default: 0.0.0.0)"
		print u"  -f    Log to given file instead of syslog"
		print u"  -c    Location of config file"
		print u"  -l    Set log level (default: 4)"
		print u"        0=nothing, 1=critical, 2=error, 3=warning, 4=notice, 5=info, 6=debug, 7=debug2, 9=confidential"
		print u""
	
	def daemonize(self):
		# Fork to allow the shell to return and to call setsid
		try:
			self._pid = os.fork()
			if (self._pid > 0):
				# Parent exits
				sys.exit(0)
		except OSError, e:
			raise Exception(u"First fork failed: %e" % e)
		
		# Do not hinder umounts
		os.chdir("/")
		# Create a new session
		os.setsid()
		
		# Fork a second time to not remain session leader
		try:
			self._pid = os.fork()
			if (self._pid > 0):
				sys.exit(0)
		except OSError, e:
			raise Exception(u"Second fork failed: %e" % e)
		
		logger.setConsoleLevel(LOG_NONE)
		
		# Close standard output and standard error.
		os.close(0)
		os.close(1)
		os.close(2)
		
		# Open standard input (0)
		if (hasattr(os, "devnull")):
			os.open(os.devnull, os.O_RDWR)
		else:
			os.open("/dev/null", os.O_RDWR)
		
		# Duplicate standard input to standard output and standard error.
		os.dup2(0, 1)
		os.dup2(0, 2)
		sys.stdout = logger.getStdout()
		sys.stderr = logger.getStderr()

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# -                                               MAIN                                                -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if (__name__ == "__main__"):
	logger.setConsoleLevel(LOG_WARNING)
	exception = None
	
	try:
		OpsiconfdInit()
		
	except SystemExit, e:
		pass
		
	except Exception, e:
		exception = e
	
	if exception:
		logger.logException(exception)
		print >> sys.stderr, u"ERROR:", unicode(exception)
		sys.exit(1)
	sys.exit(0)



